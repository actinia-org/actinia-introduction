{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A gentle introduction to actinia Authors: Markus Neteler, Carmen Tawalika, Anika Weinmann, Guido Riembauer, mundialis GmbH & Co. KG, Bonn Fork Me On GitHub URL of this dcument: https://mundialis.github.io/actinia-introduction/ This workshop is a fork of https://neteler.gitlab.io/actinia-introduction . The initial workshop has a more detailed chapter about ace - the actinia command execution. This workshop focuses more on the \"bare\" HTTP API from actinia and extended excercises. Last update: 23 Aug 2022 Abstract Actinia ( https://actinia.mundialis.de/ ) is an open source REST API for scalable, distributed, high performance processing of geographical data that uses mainly GRASS GIS for computational tasks. Core functionality includes the processing of single scenes and time series of satellite images, of raster and vector data. With the existing (e.g. Landsat) and Copernicus Sentinel big geodata pools which are growing day by day, actinia is designed to follow the paradigm of bringing algorithms to the cloud stored geodata. Actinia is an OSGeo Community Project since 2019. In this course we will briefly give a short introduction to REST API and cloud processing concepts. This is followed by an introduction to actinia processing along with hands-on to get more familiar with the topic by means of exercises. Required software for this tutorial We will use an HTTP client to try out some REST commands. This can be a command line tool, code editor plugin or browser plugin. This requires some software to be installed: REST client (one of the options below): Command line tool: cURL , to be used on command line Extensions for Chrome/Chromium browser: RESTman extension and a nice JSON Formatter Extension for code editor, here for VS Code Thunderclient plugin If you use a different editor, a similar plugin might exist Not required for this workshop but nice to have: jq , a lightweight and flexible command-line JSON processor QGIS The \"ace - actinia command execution\" section is a demonstration only. To dive deeper into this topic, you can follow these installation instructions . Note: We will use the demo actinia server at https://actinia.mundialis.de/ - hence Internet connection is required. actinia tutorial overview Content Warming up Some Concepts Why cloud computing? Overview actinia REST API and geoprocessing basics Explore First Hand-on: working with REST API requests Exploring the API: finding available actinia endpoints Client implementations actinia-python-client - A python client library ACE - Controlling actinia from a running GRASS GIS session actinia Connector - a QGIS plugin actinia Jupyter Notebooks Own exercises in actinia What is the altitude of the highest point in North Carolina? Check it with actinia. Find the zipcode in Wake county with the most hospitals Export the water bodies from the available Landsat imagery of North Carolina Population at risk near coastal areas Conclusions and future See also: openEO resources References About the trainers Warming up To make you familiar with a few concepts, let's take a look at the \"graphical intro to actinia\" - GRASS GIS in the cloud: actinia geoprocessing (note: it requires the Chrome/ium browser; presentation provided by Carmen Tawalika , mundialis).","title":"A gentle introduction to actinia"},{"location":"#a-gentle-introduction-to-actinia","text":"Authors: Markus Neteler, Carmen Tawalika, Anika Weinmann, Guido Riembauer, mundialis GmbH & Co. KG, Bonn Fork Me On GitHub URL of this dcument: https://mundialis.github.io/actinia-introduction/ This workshop is a fork of https://neteler.gitlab.io/actinia-introduction . The initial workshop has a more detailed chapter about ace - the actinia command execution. This workshop focuses more on the \"bare\" HTTP API from actinia and extended excercises. Last update: 23 Aug 2022","title":"A gentle introduction to actinia"},{"location":"#abstract","text":"Actinia ( https://actinia.mundialis.de/ ) is an open source REST API for scalable, distributed, high performance processing of geographical data that uses mainly GRASS GIS for computational tasks. Core functionality includes the processing of single scenes and time series of satellite images, of raster and vector data. With the existing (e.g. Landsat) and Copernicus Sentinel big geodata pools which are growing day by day, actinia is designed to follow the paradigm of bringing algorithms to the cloud stored geodata. Actinia is an OSGeo Community Project since 2019. In this course we will briefly give a short introduction to REST API and cloud processing concepts. This is followed by an introduction to actinia processing along with hands-on to get more familiar with the topic by means of exercises.","title":"Abstract"},{"location":"#required-software-for-this-tutorial","text":"We will use an HTTP client to try out some REST commands. This can be a command line tool, code editor plugin or browser plugin. This requires some software to be installed: REST client (one of the options below): Command line tool: cURL , to be used on command line Extensions for Chrome/Chromium browser: RESTman extension and a nice JSON Formatter Extension for code editor, here for VS Code Thunderclient plugin If you use a different editor, a similar plugin might exist Not required for this workshop but nice to have: jq , a lightweight and flexible command-line JSON processor QGIS The \"ace - actinia command execution\" section is a demonstration only. To dive deeper into this topic, you can follow these installation instructions . Note: We will use the demo actinia server at https://actinia.mundialis.de/ - hence Internet connection is required.","title":"Required software for this tutorial"},{"location":"#actinia-tutorial-overview","text":"Content Warming up Some Concepts Why cloud computing? Overview actinia REST API and geoprocessing basics Explore First Hand-on: working with REST API requests Exploring the API: finding available actinia endpoints Client implementations actinia-python-client - A python client library ACE - Controlling actinia from a running GRASS GIS session actinia Connector - a QGIS plugin actinia Jupyter Notebooks Own exercises in actinia What is the altitude of the highest point in North Carolina? Check it with actinia. Find the zipcode in Wake county with the most hospitals Export the water bodies from the available Landsat imagery of North Carolina Population at risk near coastal areas Conclusions and future See also: openEO resources References About the trainers","title":"actinia tutorial overview"},{"location":"#warming-up","text":"To make you familiar with a few concepts, let's take a look at the \"graphical intro to actinia\" - GRASS GIS in the cloud: actinia geoprocessing (note: it requires the Chrome/ium browser; presentation provided by Carmen Tawalika , mundialis).","title":"Warming up"},{"location":"2_concepts/","text":"Some Concepts For this tutorial we assume working knowledge concerning geospatial analysis and Earth observation (i.e., geodata such as raster, vector, time series, and image data including aerial, drone, and satellite data). The tutorial includes, however, a brief introduction to REST (Representational State Transfer) API basics and cloud processing related hints. Why cloud computing? With the tremendous increase of available geospatial and Earth observation lately driven by the European Copernicus programme (esp. the Sentinel satellites) and the increasing availability of open data, the need for computational resources is growing in a non-linear way. Cloud technology offers a series of advantages : scalable, distributed, and high performance processing large quantities of Earth Observation (EO) and geodata provided in dedicated cloud infrastructures addressing the paradigm of computing next to the data no need to bother yourself with the low-level management of tons of data. (Ideally) enjoy the five V\u2019s of big data : Volume, velocity, variety, veracity and value. Still, some critical issues have to be addressed in the geospatial realm: lack of Analysis-Ready-data (ARD) available for consumption in the cloud lack of compatibility between different data systems btw., we are on it: the openEO H2020 project lack of cloud abstraction, needed for easier move between vendors and providers. Overview actinia Actinia ( https://actinia.mundialis.de/ ) is an open source REST API for scalable, distributed, high performance processing of geospatial and Earth observation data that uses mainly GRASS GIS for computational tasks. Core functionality includes the processing of single scenes and time series of satellite images, of raster and vector data. With the existing (e.g. Landsat) and Copernicus Sentinel big geodata pools which are growing day by day, actinia is designed to follow the paradigm of bringing algorithms to the cloud stored geodata. Actinia is an OSGeo Community Project since 2019. The source code is available on GitHub at https://github.com/mundialis/actinia_core . It is written in Python and uses Flask, Redis, and other components. Components of actinia Actinia is composed of several components. Core system: actinia-core : an open source REST API for scalable, distributed and, high performance processing of geographical data that uses mainly GRASS GIS for computational tasks. It can be installed as is or enhanced with multiple plugins. API: actinia-api : API description for actinia_core and official plugins. Plugins: actinia-module-plugin : contains module self-description and process-chain-template management and processing actinia-metadata-plugin : contains communication with a metadata catalog via OGC-CSW, in usage with GeoNetwork opensource actinia-statistic-plugin : designed for computing raster map and raster-time-series statistics for categorical and continuous data actinia-satellite-plugin : designed for efficient satellite data handling, especially Landsat and Sentinel-2 scenes actinia-stac-plugin : Plugin for actinia to read STAC catalogs and retrieve data for processing actinia-tiling-plugin : Plugin for actinia to tile areas, e.g. to process them in parallel actinia-parallel-plugin : Plugin for actinia to allow to specify parallel processes for faster processing (WIP) ( actinia-example-plugin : A small example plugin for actinia-core. This can be used as base for developing an own plugin) Related: openeo-grassgis-driver : OpenEO driver for GRASS GIS/actinia. Backend description at https://openeo.mundialis.de/.well-known/openeo Fig. 1: Components of actinia (core and plugins) Functionality beyond GRASS GIS Actinia is not only a REST interface to GRASS GIS, but it offers the possibility to extend its functionality with other software (ESA SNAP, GDAL, ...). To integrate other than GRASS GIS software, a wrapper script is to be written (style: as a GRASS GIS Addon Python script) which then includes the respective function calls of the software to be integrated. Calling shell commands in an actinia process chain is also possible but limited due to security risks. Persistent and ephemeral databases Persistent storage refers to a data store that retains data even in the event of a power-off, as well as retaining it without a scheduled deletion time. In the geo/EO context, persistent storage is used to provide, for example, base cartography, i.e. elevation models, road networks, building footprints, etc. The ephemeral storage is used for on demand computed results including user generated data and temporary data as occurring in processing chains. In an ephemeral storage, data are only kept for a limited period of time (e.g., in actinia, for 24 hs by default). In the cloud computing context these differences are relevant as cost incurs when storing data. Accordingly, actinia offers two modes of operation: persistent and ephemeral processing. In particular, the actinia server is typically deployed on a server with access to a persistent GRASS GIS database (PDB) and optionally to one or more GRASS GIS user databases (UDB). Actinia is deployed multiple times as so called actinia nodes (separate physically distinct machines) where the actual computations are performed. They can be deployed with the help of cloud technology like e.g. kubernetes, openshift and docker-swarm. This technology then acts as a load balancer , distributing jobs to actinia nodes. Results are either stored in GRASS UDBs in GRASS native format or directly exported to a different data format (see Fig. 2). Fig. 2: Persistent and ephemeral storage with actinia nodes (source: mundialis FOSS4G talk 2019 ) Architecture of actinia Several components play a role in a cloud deployment of actinia (for an example, see Fig. 3): analytics: here are the workers of GRASS GIS or wrapped other software (GDAL, ESA-SNAP, ...), external data sources: import providers for various external data sources, interface layer: most importantly, the REST API , openEO GRASS GIS driver , ace - actinia command execution (to be run in a GRASS GIS session), metadata management: interface to Geonetwork Opensource via OGC-CSW, managed through actinia-metadata-plugin , module self-description and process-chain-template management and processing, managed through actinia-module-plugin , database system: job management in a Redis database, the GRASS GIS database (here are the geo/EO data stored!), connection to OGC Web services for output: Geoserver integration. Fig. 3: Example architecture of an actinia deployment (source: mundialis) Deployment In short, deployment means starting software, usually in an automated way on one or more computer nodes. There are a number of technologies for this. In particular, virtualisation plays an important role here, which avoids a high dependency on hardware and software characteristics through abstraction. An aim is to operate Infrastructure as Code ( IaC ), i.e. to have a set of scripts which order the needed computational resources in the cloud, setup the network and storage topology, connect to the nodes, install them with the needed software (usually docker based, i.e. so-called containers are launched from prepared images) and processing chains. Basically, the entire software part of a cloud computing infrastructure is launched \"simply\" through scripts with the advantage of restarting it easily as needed, maintain it and migrate to other hardware. CI/CD systems (continuous integration/continuous deployment) allow to define dependencies, prevent from launching broken software and allow the versioning of the entire software stack. With respect to actinia, various ways of deployment are offered: local installation, docker, docker-compose, docker-swarm, Openshift, and kubernetes. REST API and geoprocessing basics What is REST: intro An API (Application Programming Interface) defines a way of communicating between different software applications. A RESTful API (Representational State Transfer - REST, for details see https://en.wikipedia.org/wiki/Representational_state_transfer ) is a web API for communicating with web resources. In detail, a REST API uses URL arguments to specify what information shall be returned through the API. This is not much different from requesting a Web page in a browser, but through the REST API we can execute commands remotely and retrieve the results . Each URL is called a request while the data sent back to the user is called a response , after some processing was performed. There are two types of request: synchronous and asynchronous . In the case of a synchronous request, the client sends it to the server and waits for a response. In geospatial computing, processing can take some time, which would block the client because it is only waiting. In default configurations the communication is canceled by the client after some minutes, called a \"timeout\". To avoid this, there is also the asynchronous request type. Here the client does not wait directly for a response, but checks from time to time whether the job has been completed (by \"polling\"), or by providing an API itself which will be informed when the job is finished (\"webhook\"). A request requires/consists of four parts (see also [1]): the endpoint the header the data (or body) the methods Endpoint In general, an endpoint is an entry point to a service, a process, or a queue or topic destination in service-oriented architectures. In the case of actinia, it may be a data query function, the computation of a vegetation index, the deletion of a dataset, and more. Effectively, an endpoint is the URL you request for. It follows this structure: https://api.some.server/endpoint. The final part of an endpoint are the query parameters. Using query parameters you can modify your request with key-value pairs, beginning with a question mark ( ? ). With an ampersand ( & ) each parameter pair is separated, e.g.: ?query1=value1&query2=value2 As an example, we check the repositories of a GitHub user, in sorted form, using the repos endpoint + query: https://api.github.com/users/mmacata/repos?sort=pushed Header & Body Both requests and responses have two parts: a header, and optionally a body Header information contain e.g. authentication In both requests and responses, the body contains the actual data being transmitted The request body is only necessary for certain HTTP methods (e.g. HTTP POST) and can contain any form of data, e.g. an actinia process chain The response body returns information or results. Examples in actinia are json data or GeoTIFF results Methods Request methods (source: [2]): In REST APIs, every request has an HTTP method type associated with it. The most common HTTP methods (or verbs) include: GET - a GET request asks to receive a copy of a resource POST - a POST request sends data to a server in order to replace existing or create new resources PUT - a PUT request sends data to a server in order to change or update resources DELETE - a DELETE request is sent to remove or destroy a resource Response codes HTTP responses don't have methods, but they do have status codes: HTTP status codes are included in the header of every response in a REST API. Status codes include information about the result of the original request. Selected status codes (see also https://httpstatuses.com ): 200 - OK | All fine 404 - Not Found | The requested resource was not found 401 - Unauthorized | The request was rejected, as the sender is not (or wrongly) authorized 500 - Internal Server Error | Ouch, something went wrong while the server was processing your request Related data format: JSON JSON is a structured, machine readable format (while also human readable; in contrast to XML, at least for many people). JSON is short for JavaScript Object Notation. For example, this command line call... GRASS (nc_spm_08):~ > v.buffer input=roadlines output=roadbuf10 distance=10 --json ... looks like the following in JSON: { \"module\": \"v.buffer\", \"id\": \"v.buffer_1804289383\", \"inputs\":[ {\"param\": \"input\", \"value\": \"roadlines\"}, {\"param\": \"layer\", \"value\": \"-1\"}, {\"param\": \"type\", \"value\": \"point,line,area\"}, {\"param\": \"distance\", \"value\": \"10\"}, {\"param\": \"angle\", \"value\": \"0\"}, {\"param\": \"scale\", \"value\": \"1.0\"} ], \"outputs\":[ {\"param\": \"output\", \"value\": \"roadbuf10\"} ] } Hint: When writing JSON files, some linting (process of checking the source code for programmatic as well as stylistic errors) might come handy, e.g. by using https://jsonlint.com/ .","title":"Some Concepts"},{"location":"2_concepts/#some-concepts","text":"For this tutorial we assume working knowledge concerning geospatial analysis and Earth observation (i.e., geodata such as raster, vector, time series, and image data including aerial, drone, and satellite data). The tutorial includes, however, a brief introduction to REST (Representational State Transfer) API basics and cloud processing related hints.","title":"Some Concepts"},{"location":"2_concepts/#why-cloud-computing","text":"With the tremendous increase of available geospatial and Earth observation lately driven by the European Copernicus programme (esp. the Sentinel satellites) and the increasing availability of open data, the need for computational resources is growing in a non-linear way. Cloud technology offers a series of advantages : scalable, distributed, and high performance processing large quantities of Earth Observation (EO) and geodata provided in dedicated cloud infrastructures addressing the paradigm of computing next to the data no need to bother yourself with the low-level management of tons of data. (Ideally) enjoy the five V\u2019s of big data : Volume, velocity, variety, veracity and value. Still, some critical issues have to be addressed in the geospatial realm: lack of Analysis-Ready-data (ARD) available for consumption in the cloud lack of compatibility between different data systems btw., we are on it: the openEO H2020 project lack of cloud abstraction, needed for easier move between vendors and providers.","title":"Why cloud computing?"},{"location":"2_concepts/#overview-actinia","text":"Actinia ( https://actinia.mundialis.de/ ) is an open source REST API for scalable, distributed, high performance processing of geospatial and Earth observation data that uses mainly GRASS GIS for computational tasks. Core functionality includes the processing of single scenes and time series of satellite images, of raster and vector data. With the existing (e.g. Landsat) and Copernicus Sentinel big geodata pools which are growing day by day, actinia is designed to follow the paradigm of bringing algorithms to the cloud stored geodata. Actinia is an OSGeo Community Project since 2019. The source code is available on GitHub at https://github.com/mundialis/actinia_core . It is written in Python and uses Flask, Redis, and other components.","title":"Overview actinia"},{"location":"2_concepts/#components-of-actinia","text":"Actinia is composed of several components. Core system: actinia-core : an open source REST API for scalable, distributed and, high performance processing of geographical data that uses mainly GRASS GIS for computational tasks. It can be installed as is or enhanced with multiple plugins. API: actinia-api : API description for actinia_core and official plugins. Plugins: actinia-module-plugin : contains module self-description and process-chain-template management and processing actinia-metadata-plugin : contains communication with a metadata catalog via OGC-CSW, in usage with GeoNetwork opensource actinia-statistic-plugin : designed for computing raster map and raster-time-series statistics for categorical and continuous data actinia-satellite-plugin : designed for efficient satellite data handling, especially Landsat and Sentinel-2 scenes actinia-stac-plugin : Plugin for actinia to read STAC catalogs and retrieve data for processing actinia-tiling-plugin : Plugin for actinia to tile areas, e.g. to process them in parallel actinia-parallel-plugin : Plugin for actinia to allow to specify parallel processes for faster processing (WIP) ( actinia-example-plugin : A small example plugin for actinia-core. This can be used as base for developing an own plugin) Related: openeo-grassgis-driver : OpenEO driver for GRASS GIS/actinia. Backend description at https://openeo.mundialis.de/.well-known/openeo Fig. 1: Components of actinia (core and plugins) Functionality beyond GRASS GIS Actinia is not only a REST interface to GRASS GIS, but it offers the possibility to extend its functionality with other software (ESA SNAP, GDAL, ...). To integrate other than GRASS GIS software, a wrapper script is to be written (style: as a GRASS GIS Addon Python script) which then includes the respective function calls of the software to be integrated. Calling shell commands in an actinia process chain is also possible but limited due to security risks. Persistent and ephemeral databases Persistent storage refers to a data store that retains data even in the event of a power-off, as well as retaining it without a scheduled deletion time. In the geo/EO context, persistent storage is used to provide, for example, base cartography, i.e. elevation models, road networks, building footprints, etc. The ephemeral storage is used for on demand computed results including user generated data and temporary data as occurring in processing chains. In an ephemeral storage, data are only kept for a limited period of time (e.g., in actinia, for 24 hs by default). In the cloud computing context these differences are relevant as cost incurs when storing data. Accordingly, actinia offers two modes of operation: persistent and ephemeral processing. In particular, the actinia server is typically deployed on a server with access to a persistent GRASS GIS database (PDB) and optionally to one or more GRASS GIS user databases (UDB). Actinia is deployed multiple times as so called actinia nodes (separate physically distinct machines) where the actual computations are performed. They can be deployed with the help of cloud technology like e.g. kubernetes, openshift and docker-swarm. This technology then acts as a load balancer , distributing jobs to actinia nodes. Results are either stored in GRASS UDBs in GRASS native format or directly exported to a different data format (see Fig. 2). Fig. 2: Persistent and ephemeral storage with actinia nodes (source: mundialis FOSS4G talk 2019 ) Architecture of actinia Several components play a role in a cloud deployment of actinia (for an example, see Fig. 3): analytics: here are the workers of GRASS GIS or wrapped other software (GDAL, ESA-SNAP, ...), external data sources: import providers for various external data sources, interface layer: most importantly, the REST API , openEO GRASS GIS driver , ace - actinia command execution (to be run in a GRASS GIS session), metadata management: interface to Geonetwork Opensource via OGC-CSW, managed through actinia-metadata-plugin , module self-description and process-chain-template management and processing, managed through actinia-module-plugin , database system: job management in a Redis database, the GRASS GIS database (here are the geo/EO data stored!), connection to OGC Web services for output: Geoserver integration. Fig. 3: Example architecture of an actinia deployment (source: mundialis)","title":"Components of actinia"},{"location":"2_concepts/#deployment","text":"In short, deployment means starting software, usually in an automated way on one or more computer nodes. There are a number of technologies for this. In particular, virtualisation plays an important role here, which avoids a high dependency on hardware and software characteristics through abstraction. An aim is to operate Infrastructure as Code ( IaC ), i.e. to have a set of scripts which order the needed computational resources in the cloud, setup the network and storage topology, connect to the nodes, install them with the needed software (usually docker based, i.e. so-called containers are launched from prepared images) and processing chains. Basically, the entire software part of a cloud computing infrastructure is launched \"simply\" through scripts with the advantage of restarting it easily as needed, maintain it and migrate to other hardware. CI/CD systems (continuous integration/continuous deployment) allow to define dependencies, prevent from launching broken software and allow the versioning of the entire software stack. With respect to actinia, various ways of deployment are offered: local installation, docker, docker-compose, docker-swarm, Openshift, and kubernetes.","title":"Deployment"},{"location":"2_concepts/#rest-api-and-geoprocessing-basics","text":"","title":"REST API and geoprocessing basics"},{"location":"2_concepts/#what-is-rest-intro","text":"An API (Application Programming Interface) defines a way of communicating between different software applications. A RESTful API (Representational State Transfer - REST, for details see https://en.wikipedia.org/wiki/Representational_state_transfer ) is a web API for communicating with web resources. In detail, a REST API uses URL arguments to specify what information shall be returned through the API. This is not much different from requesting a Web page in a browser, but through the REST API we can execute commands remotely and retrieve the results . Each URL is called a request while the data sent back to the user is called a response , after some processing was performed. There are two types of request: synchronous and asynchronous . In the case of a synchronous request, the client sends it to the server and waits for a response. In geospatial computing, processing can take some time, which would block the client because it is only waiting. In default configurations the communication is canceled by the client after some minutes, called a \"timeout\". To avoid this, there is also the asynchronous request type. Here the client does not wait directly for a response, but checks from time to time whether the job has been completed (by \"polling\"), or by providing an API itself which will be informed when the job is finished (\"webhook\"). A request requires/consists of four parts (see also [1]): the endpoint the header the data (or body) the methods","title":"What is REST: intro"},{"location":"2_concepts/#endpoint","text":"In general, an endpoint is an entry point to a service, a process, or a queue or topic destination in service-oriented architectures. In the case of actinia, it may be a data query function, the computation of a vegetation index, the deletion of a dataset, and more. Effectively, an endpoint is the URL you request for. It follows this structure: https://api.some.server/endpoint. The final part of an endpoint are the query parameters. Using query parameters you can modify your request with key-value pairs, beginning with a question mark ( ? ). With an ampersand ( & ) each parameter pair is separated, e.g.: ?query1=value1&query2=value2 As an example, we check the repositories of a GitHub user, in sorted form, using the repos endpoint + query: https://api.github.com/users/mmacata/repos?sort=pushed","title":"Endpoint"},{"location":"2_concepts/#header-body","text":"Both requests and responses have two parts: a header, and optionally a body Header information contain e.g. authentication In both requests and responses, the body contains the actual data being transmitted The request body is only necessary for certain HTTP methods (e.g. HTTP POST) and can contain any form of data, e.g. an actinia process chain The response body returns information or results. Examples in actinia are json data or GeoTIFF results","title":"Header &amp; Body"},{"location":"2_concepts/#methods","text":"Request methods (source: [2]): In REST APIs, every request has an HTTP method type associated with it. The most common HTTP methods (or verbs) include: GET - a GET request asks to receive a copy of a resource POST - a POST request sends data to a server in order to replace existing or create new resources PUT - a PUT request sends data to a server in order to change or update resources DELETE - a DELETE request is sent to remove or destroy a resource","title":"Methods"},{"location":"2_concepts/#response-codes","text":"HTTP responses don't have methods, but they do have status codes: HTTP status codes are included in the header of every response in a REST API. Status codes include information about the result of the original request. Selected status codes (see also https://httpstatuses.com ): 200 - OK | All fine 404 - Not Found | The requested resource was not found 401 - Unauthorized | The request was rejected, as the sender is not (or wrongly) authorized 500 - Internal Server Error | Ouch, something went wrong while the server was processing your request","title":"Response codes"},{"location":"2_concepts/#related-data-format-json","text":"JSON is a structured, machine readable format (while also human readable; in contrast to XML, at least for many people). JSON is short for JavaScript Object Notation. For example, this command line call... GRASS (nc_spm_08):~ > v.buffer input=roadlines output=roadbuf10 distance=10 --json ... looks like the following in JSON: { \"module\": \"v.buffer\", \"id\": \"v.buffer_1804289383\", \"inputs\":[ {\"param\": \"input\", \"value\": \"roadlines\"}, {\"param\": \"layer\", \"value\": \"-1\"}, {\"param\": \"type\", \"value\": \"point,line,area\"}, {\"param\": \"distance\", \"value\": \"10\"}, {\"param\": \"angle\", \"value\": \"0\"}, {\"param\": \"scale\", \"value\": \"1.0\"} ], \"outputs\":[ {\"param\": \"output\", \"value\": \"roadbuf10\"} ] } Hint: When writing JSON files, some linting (process of checking the source code for programmatic as well as stylistic errors) might come handy, e.g. by using https://jsonlint.com/ .","title":"Related data format: JSON"},{"location":"3_explore/","text":"Explore First Hand-on: working with REST API requests Step by step... We will now send a REST API call to the actinia server and receive the server response. Step 1: Get your credentials (for authentication) from the trainer or use the demouser with gu3st!pa55w0rd Step 2: First try the following API call; simply in a browser: https://actinia.mundialis.de/api/v3/locations What does it show? Step 3: Choose and launch your REST client: cURL or RESTman or ... a) cURL , on command line b) Thunderclient plugin , for VS Code editor or find a plugin for your favorite editor c) RESTman ( manual ), in Browser Try the same request again: Fig. 4: Using RESTman For a curl example, see below (\" REST actinia examples with curl \"). Step 4: Explore the existing data on the actinia server: i.e., available GRASS locations, info, mapsets, raster, vector, and space-time datasets Check the list of data currently available on the actinia server e.g. https://actinia.mundialis.de/api/v3/locations https://actinia.mundialis.de/api/v3/locations/nc_spm_08/info https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/landsat/raster_layers https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/landsat/raster_layers/lsat5_1987_10 Note: process_results are ordered alphabetically, not thematically Bonus: use the render endpoint. Here, no JSON but an image is returned: https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/landsat/raster_layers/lsat5_1987_10/render Summary So far we have seen some REST basics and explored a few endpoints provided by actinia. Indeed the structure of the endpoints follow some GRASS GIS concepts (compare the graphical introduction above), but this does not limit us much from processing \"any\" geospatial data. Exploring the API: finding available actinia endpoints The actinia REST API documentation is available online (directly generated from the source code of actinia). Check out some of the various sections in the actinia API docs : Module Viewer Process Chain Template Management Authentication Management API Log Cache Management File Management Satellite Image Algorithms Location Management Mapset Management Processing Raster Management Raster Statistics STRDS Management (STRDS = space-time raster data set) STRDS Sampling STRDS Statistics Vector Management Mapsets GeoNetwork Resource Management Process Chain Monitoring Resource Iteration Management User Management List of endpoints, shown in the web browser: To see a simple list of endpoints (and more), have a look at the \"paths\" section in the API JSON . If the formatting looks \"ugly\", get the JSON Formatter extension. Fig. 5: actinia list of endpoints (in the \"paths\" section) List of supported processes (> 500): see API modules (note: the process chain templates are at bottom, category \"actinia-module\") Fig. 6: actinia list of GRASS GIS processes (> 500) List of endpoints shown on command line: To get the available endpoints on command line, run ## we filter the paths on the fly with `jq` # note: no AUTH needed curl --no-progress-meter -X GET https://actinia.mundialis.de/api/v3/swagger.json | jq \".\"paths | jq 'keys' [ \"/actinia_modules\", \"/actinia_modules/{actiniamodule}\", \"/actinia_templates\", \"/actinia_templates/{template_id}\", \"/api_key\", \"/api_log/{user_id}\", \"/download_cache\", \"/files\", \"/grass_modules\", \"/grass_modules/{grassmodule}\", \"/landsat_process/{landsat_id}/{atcor_method}/{processing_method}\", \"/landsat_query\", \"/locations\", \"/locations/{location_name}\", \"/locations/{location_name}/info\", \"/locations/{location_name}/mapsets\", \"/locations/{location_name}/mapsets/{mapset_name}\", \"/locations/{location_name}/mapsets/{mapset_name}/info\", ... \"/sentinel2_query\", \"/sentinel2a_aws_query\", \"/token\", \"/users\", \"/users/{user_id}\" ] REST actinia examples with curl Here we use the command line and the curl software to communicate with the actinia server. Optionally, to beautify the output, we use the jq command-line JSON processor which helps to turn the output into something human readable ( download jq ). Hint: If you have troubles to use jq on command line, you can also use it in a browser at https://jqplay.org/ : copy the JSON code into the \"JSON\" field, then a . into the \"Filter\" field and it will show the result. Preparation To simplify our life in terms of server communication we store the credentials and REST server URL in environmental variables (this is only relevant for command line usage; in RESTman the browser will request the credentials): # set credentials and REST server URL export actinia=\"https://actinia.mundialis.de\" export AUTH='-u demouser:gu3st!pa55w0rd' List available locations First, we want to see the list of available \"locations\". A location in GRASS-speak is simply a project folder which contains geospatial data: # show available locations (locations are like projects) curl ${AUTH} -X GET ${actinia}/api/v3/locations List mapsets in locations Next, we look at so-called \"mapsets\" which are subfolders in a location (just to better organise the geospatial data): # show available mapsets of a specific location curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets\" Note the style difference of output: # show available mapsets of a specific location curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets\" | jq List map layers and their metadata Eventually, digging more for content in \"location\" and \"mapsets\", we can look at the datasets stored therein: Vector data: # show available vector maps in a specific location/mapset curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/PERMANENT/vector_layers\" curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/PERMANENT/vector_layers\" | jq # note: you can always add `| jq` # show metadata of a specific vector map curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/PERMANENT/vector_layers/geology\" Raster data: # show available raster maps in a specific location/mapset curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/PERMANENT/raster_layers\" curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/landsat/raster_layers\" curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/modis_lst/raster_layers\" # show metadata of a specific raster map curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/landsat/raster_layers/lsat7_2000_40\" Space-time raster datasets (STRDS): # show available STRDS in a specific location/mapset # MODIS Land Surface Temperature data curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/modis_lst/strds\" # show specific STRDS in a specific location/mapset # MODIS Normalized Difference Vegetation Index curl ${AUTH} -X GET \"${actinia}/api/v3/locations/latlong_wgs84/mapsets/modis_ndvi_global/strds/ndvi_16_5600m\" # Get a list or raster layers from a STRDS # ECAD: Yearly precipitation curl ${AUTH} -X GET \"${actinia}/api/v3/locations/ECAD/mapsets/PERMANENT/strds/precipitation_1950_2013_yearly_mm/raster_layers\" # Get a list or raster layers from a STRDS, with date filter # ECAD: Yearly precipitation curl ${AUTH} -X GET \"${actinia}/api/v3/locations/ECAD/mapsets/PERMANENT/strds/precipitation_1950_2013_yearly_mm/raster_layers?where=start_time>'2012-01-01'\" Render maps This can be achieved by simply adding /render at the end of a layer resource: curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/PERMANENT/raster_layers/geology_30m/render\" > geology_30m.png curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/landsat/raster_layers/lsat7_2000_40/render\" > lsat7_2000_40.png Map layer and space-time cube queries It's time to retrieve something from the server. We want to query the stack of multitemporal datasets available and more specifically, retrieve MODIS Land Surface Temperature (LST) values from the space-time cube at a specific position (North Carolina data set; at 78W, 36N ). For this, we use the endpoint sampling_sync_geojson : # query point value in a STRDS, sending a GeoJSON file of the point position along with the request # (North Carolina LST time series) curl ${AUTH} -X POST -H \"content-type: application/json\" \"${actinia}/api/v3/locations/nc_spm_08/mapsets/modis_lst/strds/LST_Day_monthly/sampling_sync_geojson\" -d '{\"type\":\"FeatureCollection\",\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"urn:ogc:def:crs:EPSG::4326\"}},\"features\":[{\"type\":\"Feature\",\"properties\":{\"cat\":1},\"geometry\":{\"type\":\"Point\",\"coordinates\":[-78,36]}}]}' Using RESTman you need to pay attention to these changes: change type of request from GET to POST, in the top of the page lefthand of the URL set the right header content-type and application/json as value add the JSON in the body section in RAW format Fig. 7 RESTman POST request example (source: Luca Delucchi) Sending JSON payload as a file In the example above we have sent JSON code to the server directly in the request. However, with longer process chains this is hard to manage. It is often much more convenient to store the JSON code as \"payload\" in a file and send it to the server: # note: you can easily generate such a GeoJSON file with ogr2ogr or v.out.ogr # # store the query in a JSON file \"pc_query_point_.json\" (or use a text editor for this) echo '{\"type\":\"FeatureCollection\",\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"urn:ogc:def:crs:EPSG::4326\"}},\"features\":[{\"type\":\"Feature\",\"properties\":{\"cat\":1},\"geometry\":{\"type\":\"Point\",\"coordinates\":[-78,36]}}]}' > pc_query_point_.json # send JSON file as payload to query the STRDS curl ${AUTH} -X POST -H \"content-type: application/json\" \"${actinia}/api/v3/locations/nc_spm_08/mapsets/modis_lst/strds/LST_Day_monthly/sampling_sync_geojson\" -d @pc_query_point_.json | jq Validation of a process chain Why validation? It may happen that your JSON file to be sent to the endpoint contains a typo or other invalid content. For the identification of problems prior to executing the commands contained in the JSON file (which may last for hours), it is recommended to validate this file. For this, actinia can be used as it provides a validation endpoint. Example: Download the process chain process_chain_long.json and validate it: # validation of a process chain (using sync call) curl ${AUTH} -H \"Content-Type: application/json\" -X POST \"${actinia}/api/v3/locations/nc_spm_08/process_chain_validation_sync\" -d @process_chain_long.json Converting a process chain back into commands To turn a process chain back into command style notation, the validator can be used and the relevant code extracted from the resulting JSON response. Download the process chain process_chain_long.json and extract the section containing the underlying commands by parsing the actinia server response with jq : # command extraction from a process chain (using sync call) by parsing the 'process_results' response (here we use the `jq` tool:) curl ${AUTH} --no-progress-meter -H \"Content-Type: application/json\" -X POST \"${actinia}/api/v3/locations/nc_spm_08/process_chain_validation_sync\" -d @process_chain_long.json | jq \".\"process_results [ \"grass g.region ['raster=elevation@PERMANENT', 'res=10', '-p']\", \"grass r.slope.aspect ['elevation=elevation@PERMANENT', 'format=degrees', 'precision=FCELL', 'zscale=1.0', 'min_slope=0.0', 'slope=my_slope', 'aspect=my_aspect', '-a']\", \"grass r.watershed ['elevation=elevation@PERMANENT', 'convergence=5', 'memory=500', 'accumulation=my_accumulation']\", \"grass r.info ['map=my_aspect', '-gr']\" ] Data exchange: import and export Actinia can import from external Web resources, use data in the actinia server (persistent and ephemeral storage) and make results available for download as Web resources. These latter can then be downloaded, opened by QGIS, imported into GRASS GIS or other software. Note that the download of Web resources provided by actinia requires authentication, e.g. the demouser . Available export formats At time (more to come) the following export formats are supported: raster: COG , GTiff strds: GTiff (multiple files packed in an tar.gz archive) vector: PostgreSQL , GPKG , GML , GeoJSON , ESRI_Shapefile , SQLite , CSV file: CSV , TXT Dealing with workflows (processing chains) The overall goal is to \"get stuff done\". In this case it means that we can concatenate (chain) a series of commands where the output of one step may be used as the input of the following step. The general procedure comprises: prepare a processing chain compare async(cronous) versus sync(cronous) REST API calls, decide which endpoint to use submit the processing chain to an actinia endpoint retrieve the result(s). To turn this concept into an example, we use again the process chain process_chain_long.json from above and execute it, here using the asynchonous processing_async_export endpoint. By this, the exporter in the process chain will be activated and deliver the computed maps as Web resources for subsequent download: curl ${AUTH} --no-progress-meter -H \"Content-Type: application/json\" -X POST \"${actinia}/api/v3/locations/nc_spm_08/processing_async_export\" -d @process_chain_long.json | jq Being an asynchronous process, the result is not offered directly but at the bottom of the JSON output (in the terminal) a resource ID (red box) and a resource URI is shown: Use this URI for retrieving the process status, e.g. using your browser ( F5 to reload page until job is ready). Once the job has been completed (\"Processing successfully finished\"), three Web resources (here: COG - Cloud Optimized GeoTIFF) are shown at the bottom of the JSON output: # update the URI to that of your job, and be sure to use https: curl ${AUTH} -X GET \"https://actinia.mundialis.de/api/v3/resources/demouser/resource_id-284d42c7-9ba7-415d-b675-cf1a534f4af0\" | jq ... \"status\": \"finished\", \"time_delta\": 3.7403182983398438, \"timestamp\": 1580767679.525925, \"urls\": { \"resources\": [ \"http://actinia.mundialis.de/api/v3/resources/demouser/resource_id-284d42c7-9ba7-415d-b675-cf1a534f4af0/my_slope.tiff\", \"http://actinia.mundialis.de/api/v3/resources/demouser/resource_id-284d42c7-9ba7-415d-b675-cf1a534f4af0/my_aspect.tiff\", \"http://actinia.mundialis.de/api/v3/resources/demouser/resource_id-284d42c7-9ba7-415d-b675-cf1a534f4af0/my_accumulation.tiff\" ], \"status\": \"http://actinia.mundialis.de/api/v3/resources/demouser/resource_id-284d42c7-9ba7-415d-b675-cf1a534f4af0\" }, \"user_id\": \"demouser\" } The resulting files can now be downloaded (they'll remain for 24 hs on the server). Fig. 8: actinia output shown in QGIS (aspect map)","title":"Explore"},{"location":"3_explore/#explore","text":"","title":"Explore"},{"location":"3_explore/#first-hand-on-working-with-rest-api-requests","text":"","title":"First Hand-on: working with REST API requests"},{"location":"3_explore/#step-by-step","text":"We will now send a REST API call to the actinia server and receive the server response. Step 1: Get your credentials (for authentication) from the trainer or use the demouser with gu3st!pa55w0rd Step 2: First try the following API call; simply in a browser: https://actinia.mundialis.de/api/v3/locations What does it show? Step 3: Choose and launch your REST client: cURL or RESTman or ... a) cURL , on command line b) Thunderclient plugin , for VS Code editor or find a plugin for your favorite editor c) RESTman ( manual ), in Browser Try the same request again: Fig. 4: Using RESTman For a curl example, see below (\" REST actinia examples with curl \"). Step 4: Explore the existing data on the actinia server: i.e., available GRASS locations, info, mapsets, raster, vector, and space-time datasets Check the list of data currently available on the actinia server e.g. https://actinia.mundialis.de/api/v3/locations https://actinia.mundialis.de/api/v3/locations/nc_spm_08/info https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/landsat/raster_layers https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/landsat/raster_layers/lsat5_1987_10 Note: process_results are ordered alphabetically, not thematically Bonus: use the render endpoint. Here, no JSON but an image is returned: https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/landsat/raster_layers/lsat5_1987_10/render","title":"Step by step..."},{"location":"3_explore/#summary","text":"So far we have seen some REST basics and explored a few endpoints provided by actinia. Indeed the structure of the endpoints follow some GRASS GIS concepts (compare the graphical introduction above), but this does not limit us much from processing \"any\" geospatial data.","title":"Summary"},{"location":"3_explore/#exploring-the-api-finding-available-actinia-endpoints","text":"The actinia REST API documentation is available online (directly generated from the source code of actinia). Check out some of the various sections in the actinia API docs : Module Viewer Process Chain Template Management Authentication Management API Log Cache Management File Management Satellite Image Algorithms Location Management Mapset Management Processing Raster Management Raster Statistics STRDS Management (STRDS = space-time raster data set) STRDS Sampling STRDS Statistics Vector Management Mapsets GeoNetwork Resource Management Process Chain Monitoring Resource Iteration Management User Management List of endpoints, shown in the web browser: To see a simple list of endpoints (and more), have a look at the \"paths\" section in the API JSON . If the formatting looks \"ugly\", get the JSON Formatter extension. Fig. 5: actinia list of endpoints (in the \"paths\" section) List of supported processes (> 500): see API modules (note: the process chain templates are at bottom, category \"actinia-module\") Fig. 6: actinia list of GRASS GIS processes (> 500) List of endpoints shown on command line: To get the available endpoints on command line, run ## we filter the paths on the fly with `jq` # note: no AUTH needed curl --no-progress-meter -X GET https://actinia.mundialis.de/api/v3/swagger.json | jq \".\"paths | jq 'keys' [ \"/actinia_modules\", \"/actinia_modules/{actiniamodule}\", \"/actinia_templates\", \"/actinia_templates/{template_id}\", \"/api_key\", \"/api_log/{user_id}\", \"/download_cache\", \"/files\", \"/grass_modules\", \"/grass_modules/{grassmodule}\", \"/landsat_process/{landsat_id}/{atcor_method}/{processing_method}\", \"/landsat_query\", \"/locations\", \"/locations/{location_name}\", \"/locations/{location_name}/info\", \"/locations/{location_name}/mapsets\", \"/locations/{location_name}/mapsets/{mapset_name}\", \"/locations/{location_name}/mapsets/{mapset_name}/info\", ... \"/sentinel2_query\", \"/sentinel2a_aws_query\", \"/token\", \"/users\", \"/users/{user_id}\" ]","title":"Exploring the API: finding available actinia endpoints"},{"location":"3_explore/#rest-actinia-examples-with-curl","text":"Here we use the command line and the curl software to communicate with the actinia server. Optionally, to beautify the output, we use the jq command-line JSON processor which helps to turn the output into something human readable ( download jq ). Hint: If you have troubles to use jq on command line, you can also use it in a browser at https://jqplay.org/ : copy the JSON code into the \"JSON\" field, then a . into the \"Filter\" field and it will show the result.","title":"REST actinia examples with curl"},{"location":"3_explore/#preparation","text":"To simplify our life in terms of server communication we store the credentials and REST server URL in environmental variables (this is only relevant for command line usage; in RESTman the browser will request the credentials): # set credentials and REST server URL export actinia=\"https://actinia.mundialis.de\" export AUTH='-u demouser:gu3st!pa55w0rd'","title":"Preparation"},{"location":"3_explore/#list-available-locations","text":"First, we want to see the list of available \"locations\". A location in GRASS-speak is simply a project folder which contains geospatial data: # show available locations (locations are like projects) curl ${AUTH} -X GET ${actinia}/api/v3/locations","title":"List available locations"},{"location":"3_explore/#list-mapsets-in-locations","text":"Next, we look at so-called \"mapsets\" which are subfolders in a location (just to better organise the geospatial data): # show available mapsets of a specific location curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets\" Note the style difference of output: # show available mapsets of a specific location curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets\" | jq","title":"List mapsets in locations"},{"location":"3_explore/#list-map-layers-and-their-metadata","text":"Eventually, digging more for content in \"location\" and \"mapsets\", we can look at the datasets stored therein: Vector data: # show available vector maps in a specific location/mapset curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/PERMANENT/vector_layers\" curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/PERMANENT/vector_layers\" | jq # note: you can always add `| jq` # show metadata of a specific vector map curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/PERMANENT/vector_layers/geology\" Raster data: # show available raster maps in a specific location/mapset curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/PERMANENT/raster_layers\" curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/landsat/raster_layers\" curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/modis_lst/raster_layers\" # show metadata of a specific raster map curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/landsat/raster_layers/lsat7_2000_40\" Space-time raster datasets (STRDS): # show available STRDS in a specific location/mapset # MODIS Land Surface Temperature data curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/modis_lst/strds\" # show specific STRDS in a specific location/mapset # MODIS Normalized Difference Vegetation Index curl ${AUTH} -X GET \"${actinia}/api/v3/locations/latlong_wgs84/mapsets/modis_ndvi_global/strds/ndvi_16_5600m\" # Get a list or raster layers from a STRDS # ECAD: Yearly precipitation curl ${AUTH} -X GET \"${actinia}/api/v3/locations/ECAD/mapsets/PERMANENT/strds/precipitation_1950_2013_yearly_mm/raster_layers\" # Get a list or raster layers from a STRDS, with date filter # ECAD: Yearly precipitation curl ${AUTH} -X GET \"${actinia}/api/v3/locations/ECAD/mapsets/PERMANENT/strds/precipitation_1950_2013_yearly_mm/raster_layers?where=start_time>'2012-01-01'\"","title":"List map layers and their metadata"},{"location":"3_explore/#render-maps","text":"This can be achieved by simply adding /render at the end of a layer resource: curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/PERMANENT/raster_layers/geology_30m/render\" > geology_30m.png curl ${AUTH} -X GET \"${actinia}/api/v3/locations/nc_spm_08/mapsets/landsat/raster_layers/lsat7_2000_40/render\" > lsat7_2000_40.png","title":"Render maps"},{"location":"3_explore/#map-layer-and-space-time-cube-queries","text":"It's time to retrieve something from the server. We want to query the stack of multitemporal datasets available and more specifically, retrieve MODIS Land Surface Temperature (LST) values from the space-time cube at a specific position (North Carolina data set; at 78W, 36N ). For this, we use the endpoint sampling_sync_geojson : # query point value in a STRDS, sending a GeoJSON file of the point position along with the request # (North Carolina LST time series) curl ${AUTH} -X POST -H \"content-type: application/json\" \"${actinia}/api/v3/locations/nc_spm_08/mapsets/modis_lst/strds/LST_Day_monthly/sampling_sync_geojson\" -d '{\"type\":\"FeatureCollection\",\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"urn:ogc:def:crs:EPSG::4326\"}},\"features\":[{\"type\":\"Feature\",\"properties\":{\"cat\":1},\"geometry\":{\"type\":\"Point\",\"coordinates\":[-78,36]}}]}' Using RESTman you need to pay attention to these changes: change type of request from GET to POST, in the top of the page lefthand of the URL set the right header content-type and application/json as value add the JSON in the body section in RAW format Fig. 7 RESTman POST request example (source: Luca Delucchi)","title":"Map layer and space-time cube queries"},{"location":"3_explore/#sending-json-payload-as-a-file","text":"In the example above we have sent JSON code to the server directly in the request. However, with longer process chains this is hard to manage. It is often much more convenient to store the JSON code as \"payload\" in a file and send it to the server: # note: you can easily generate such a GeoJSON file with ogr2ogr or v.out.ogr # # store the query in a JSON file \"pc_query_point_.json\" (or use a text editor for this) echo '{\"type\":\"FeatureCollection\",\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"urn:ogc:def:crs:EPSG::4326\"}},\"features\":[{\"type\":\"Feature\",\"properties\":{\"cat\":1},\"geometry\":{\"type\":\"Point\",\"coordinates\":[-78,36]}}]}' > pc_query_point_.json # send JSON file as payload to query the STRDS curl ${AUTH} -X POST -H \"content-type: application/json\" \"${actinia}/api/v3/locations/nc_spm_08/mapsets/modis_lst/strds/LST_Day_monthly/sampling_sync_geojson\" -d @pc_query_point_.json | jq","title":"Sending JSON payload as a file"},{"location":"3_explore/#validation-of-a-process-chain","text":"Why validation? It may happen that your JSON file to be sent to the endpoint contains a typo or other invalid content. For the identification of problems prior to executing the commands contained in the JSON file (which may last for hours), it is recommended to validate this file. For this, actinia can be used as it provides a validation endpoint. Example: Download the process chain process_chain_long.json and validate it: # validation of a process chain (using sync call) curl ${AUTH} -H \"Content-Type: application/json\" -X POST \"${actinia}/api/v3/locations/nc_spm_08/process_chain_validation_sync\" -d @process_chain_long.json","title":"Validation of a process chain"},{"location":"3_explore/#converting-a-process-chain-back-into-commands","text":"To turn a process chain back into command style notation, the validator can be used and the relevant code extracted from the resulting JSON response. Download the process chain process_chain_long.json and extract the section containing the underlying commands by parsing the actinia server response with jq : # command extraction from a process chain (using sync call) by parsing the 'process_results' response (here we use the `jq` tool:) curl ${AUTH} --no-progress-meter -H \"Content-Type: application/json\" -X POST \"${actinia}/api/v3/locations/nc_spm_08/process_chain_validation_sync\" -d @process_chain_long.json | jq \".\"process_results [ \"grass g.region ['raster=elevation@PERMANENT', 'res=10', '-p']\", \"grass r.slope.aspect ['elevation=elevation@PERMANENT', 'format=degrees', 'precision=FCELL', 'zscale=1.0', 'min_slope=0.0', 'slope=my_slope', 'aspect=my_aspect', '-a']\", \"grass r.watershed ['elevation=elevation@PERMANENT', 'convergence=5', 'memory=500', 'accumulation=my_accumulation']\", \"grass r.info ['map=my_aspect', '-gr']\" ]","title":"Converting a process chain back into commands"},{"location":"3_explore/#data-exchange-import-and-export","text":"Actinia can import from external Web resources, use data in the actinia server (persistent and ephemeral storage) and make results available for download as Web resources. These latter can then be downloaded, opened by QGIS, imported into GRASS GIS or other software. Note that the download of Web resources provided by actinia requires authentication, e.g. the demouser . Available export formats At time (more to come) the following export formats are supported: raster: COG , GTiff strds: GTiff (multiple files packed in an tar.gz archive) vector: PostgreSQL , GPKG , GML , GeoJSON , ESRI_Shapefile , SQLite , CSV file: CSV , TXT","title":"Data exchange: import and export"},{"location":"3_explore/#dealing-with-workflows-processing-chains","text":"The overall goal is to \"get stuff done\". In this case it means that we can concatenate (chain) a series of commands where the output of one step may be used as the input of the following step. The general procedure comprises: prepare a processing chain compare async(cronous) versus sync(cronous) REST API calls, decide which endpoint to use submit the processing chain to an actinia endpoint retrieve the result(s). To turn this concept into an example, we use again the process chain process_chain_long.json from above and execute it, here using the asynchonous processing_async_export endpoint. By this, the exporter in the process chain will be activated and deliver the computed maps as Web resources for subsequent download: curl ${AUTH} --no-progress-meter -H \"Content-Type: application/json\" -X POST \"${actinia}/api/v3/locations/nc_spm_08/processing_async_export\" -d @process_chain_long.json | jq Being an asynchronous process, the result is not offered directly but at the bottom of the JSON output (in the terminal) a resource ID (red box) and a resource URI is shown: Use this URI for retrieving the process status, e.g. using your browser ( F5 to reload page until job is ready). Once the job has been completed (\"Processing successfully finished\"), three Web resources (here: COG - Cloud Optimized GeoTIFF) are shown at the bottom of the JSON output: # update the URI to that of your job, and be sure to use https: curl ${AUTH} -X GET \"https://actinia.mundialis.de/api/v3/resources/demouser/resource_id-284d42c7-9ba7-415d-b675-cf1a534f4af0\" | jq ... \"status\": \"finished\", \"time_delta\": 3.7403182983398438, \"timestamp\": 1580767679.525925, \"urls\": { \"resources\": [ \"http://actinia.mundialis.de/api/v3/resources/demouser/resource_id-284d42c7-9ba7-415d-b675-cf1a534f4af0/my_slope.tiff\", \"http://actinia.mundialis.de/api/v3/resources/demouser/resource_id-284d42c7-9ba7-415d-b675-cf1a534f4af0/my_aspect.tiff\", \"http://actinia.mundialis.de/api/v3/resources/demouser/resource_id-284d42c7-9ba7-415d-b675-cf1a534f4af0/my_accumulation.tiff\" ], \"status\": \"http://actinia.mundialis.de/api/v3/resources/demouser/resource_id-284d42c7-9ba7-415d-b675-cf1a534f4af0\" }, \"user_id\": \"demouser\" } The resulting files can now be downloaded (they'll remain for 24 hs on the server). Fig. 8: actinia output shown in QGIS (aspect map)","title":"Dealing with workflows (processing chains)"},{"location":"4_clients/","text":"Client implementations actinia-python-client Python library to access an actinia server easily via python. See also source code and full documentation Installation VERSION=\"0.1.2\" pip3 install \"actinia-python-client @ https://github.com/mundialis/actinia-python-client/releases/download/${VERSION}/actinia_python_client-${VERSION}-py3-none-any.whl\" Quickstart Connecting actinia Python library with actinia from actinia import Actinia actinia_mundialis = Actinia() actinia_mundialis.get_version() or connect to actinia-dev with version 3: from actinia import Actinia actinia_dev_mundialis = Actinia(\"https://actinia-dev.mundialis.de/\", \"v3\") actinia_dev_mundialis.get_version() Set authentication to get access to the actinia functionallity actinia_mundialis.set_authentication(\"demouser\", \"gu3st!pa55w0rd\") Location Management With the location management the locations can be requested as well as information of each location. Also a location can be created and deleted if the user is permitted. Get locations and locaton information of a special location: locations = actinia_mundialis.get_locations() print(locations.keys()) locations[\"nc_spm_08\"].get_info() # or actinia_mundialis.locations[\"nc_spm_08\"].get_info() Create a new location (Attention: The demouser is not permitted to create or delete a location!) new_location = actinia_mundialis.create_location(\"test_location\", 25832) print(new_location.name) print(new_location.region) print([loc for loc in actinia_mundialis.locations]) Delete a location (Attention: The demouser is not permitted to create or delete a location!) actinia_mundialis.locations[\"test_location\"].delete() print([loc for loc in actinia_mundialis.locations()]) Mapset Management With the mapset management the mapsets of a specified location can be requested as well as information of each mapset. Upcoming: Create and delete mapsets if the user is permitted. Get Mapsets of Specified Location Get mapsets of the nc_spm_08 location: mapsets = actinia_mundialis.locations[\"nc_spm_08\"].get_mapsets() print(mapsets.keys()) Raster, Vector and STRDS Management Raster manangement Get all rasters of the PERMANENT mapsets rasters = mapsets[\"PERMANENT\"].get_raster_layers() print(rasters.keys()) Get information of the raster zipcodes info = rasters[\"zipcodes\"].get_info() Upload a GTif as raster layer to a user mapset (here the user mapset will be created before) # TODO add mapset creation mapset_name = \"test_mapset\" # upload tif raster_layer_name = \"test\" file = \"/home/testuser/data/elevation.tif\" locations[\"nc_spm_08\"].mapsets[mapset_name].upload_raster(raster_layer_name, file) print(locations[\"nc_spm_08\"].mapsets[mapset_name].raster_layers.keys()) Delete a raster layer locations[\"nc_spm_08\"].mapsets[mapset_name].delete_raster(raster_layer_name) print(locations[\"nc_spm_08\"].mapsets[mapset_name].raster_layers.keys()) # TODO delete mapset Vector manangement Get all vector maps of the PERMANENT mapsets vectors = mapsets[\"PERMANENT\"].get_vector_layers() print(vectors.keys()) Get information of the vector boundary_county info = vectors[\"boundary_county\"].get_info() Upload a GeoJSON as vector layer to a user mapset (here the user mapset will be created before) # TODO add mapset creation mapset_name = \"test_mapset\" # upload tif vector_layer_name = \"test\" file = \"/home/testuser/data/firestations.geojson\" locations[\"nc_spm_08\"].mapsets[mapset_name].upload_vector(vector_layer_name, file) print(locations[\"nc_spm_08\"].mapsets[mapset_name].vector_layers.keys()) Delete a raster layer locations[\"nc_spm_08\"].mapsets[mapset_name].delete_vector(vector_layer_name) print(locations[\"nc_spm_08\"].mapsets[mapset_name].vector_layers.keys()) # TODO delete mapset Process Chain Validation A process chain can be validated before a job is started. First connecting actinia Python library with actinia and set authentication: from actinia import Actinia actinia_mundialis = Actinia() actinia_mundialis.get_version() actinia_mundialis.set_authentication(\"demouser\", \"gu3st!pa55w0rd\") # request all locations locations = actinia_mundialis.get_locations() Synchronous process chain validation pc = { \"list\": [ { \"id\": \"r_mapcalc\", \"module\": \"r.mapcalc\", \"inputs\": [ { \"param\": \"expression\", \"value\": \"elevation=42\" } ] } ], \"version\": \"1\" } pc = {\"list\": [{\"id\": \"r_mapcalc\",\"module\": \"r.mapcalc\",\"inputs\": [{\"param\": \"expression\",\"value\": \"elevation=42\"}]}],\"version\": \"1\"} actinia_mundialis.locations[\"nc_spm_08\"].validate_process_chain_sync(pc) Asynchronous process chain validation: pc = { \"list\": [ { \"id\": \"r_mapcalc\", \"module\": \"r.mapcalc\", \"inputs\": [ { \"param\": \"expression\", \"value\": \"elevation=42\" } ] } ], \"version\": \"1\" } pc = {\"list\": [{\"id\": \"r_mapcalc\",\"module\": \"r.mapcalc\",\"inputs\": [{\"param\": \"expression\",\"value\": \"elevation=42\"}]}],\"version\": \"1\"} val_job = actinia_mundialis.locations[\"nc_spm_08\"].validate_process_chain_async(pc) val_job.poll_until_finished() print(val_job.status) print(val_job.message) Processing Start a processing job with a valid process chain. First connect actinia Python library with actinia and set authentication: from actinia import Actinia actinia_mundialis = Actinia() actinia_mundialis.get_version() actinia_mundialis.set_authentication(\"demouser\", \"gu3st!pa55w0rd\") # request all locations locations = actinia_mundialis.get_locations() Ephemeral Processing Start an ephemeral processing job pc = { \"list\": [ { \"id\": \"r_mapcalc\", \"module\": \"r.mapcalc\", \"inputs\": [ { \"param\": \"expression\", \"value\": \"baum=5\" } ] } ], \"version\": \"1\" } job = actinia_mundialis.locations[\"nc_spm_08\"].create_processing_export_job(pc, \"test\") job.poll_until_finished() print(job.status) print(job.message) ACE - Controlling actinia from a running GRASS GIS session Python library to access an actinia server easily via python. Introduction to ace - actinia command execution Controlling actinia from a running GRASS GIS session is a convenient way of writing process chains. It requires some basic GRASS GIS knowledge (for an intro course, e.g. see here ). The ace (actinia command execution) tool allows the execution of a single GRASS GIS command or a list of GRASS GIS commands on an actinia REST service (e.g., https://actinia.mundialis.de/). In addition it provides job management, the ability to list locations, mapsets and map layer the user has access to as well as the creation and deletion of mapsets. The ace tool is a GRASS GIS addon and must be executed in an active GRASS GIS session. All commands will be executed per default in an ephemeral database on the actinia server. Hence, generated output must be exported using augmented GRASS commands to be able to further use it. Note: The option mapset=MAPSET_NAME allows the execution of commands in the persistent user database. It can be used with location=LOCATION_NAME option. Preparation To use ace, some things are required: GRASS GIS ( download ) three additional Python packages: click requests simplejson pip3 install click requests simplejson nc_spm_08 North Carolina sample location An empty test mapset ace (only for demo) grass -c nc_spm_08/ace ace itself, importer and exporter tools as GRASS GIS extensions g.extension extension=importer url=https://github.com/mundialis/importer g.extension extension=exporter url=https://github.com/mundialis/exporter g.extension extension=ace url=https://github.com/mundialis/ace For more detailed information on how to set this up yourself, see different actinia workshop . Authentication settings The user must setup the following environmental variables to specify the actinia server and credentials: # set credentials and REST server URL export ACTINIA_USER='demouser' export ACTINIA_PASSWORD='gu3st!pa55w0rd' export ACTINIA_URL='https://actinia.mundialis.de/' List locations, mapsets and maps In order to list the locations the user has access to, run ace -l ['latlong_wgs84', 'nc_spm_08', 'ECAD'] The following command lists mapsets of current location in the active GRASS GIS session (\"nc_spm_08\"): # running ace in the \"nc_spm_08\" location on server: ace location=\"nc_spm_08\" -m ['PERMANENT', 'landsat', 'modis_lst'] All following commands can be executed in any active GRASS GIS location, since the location name at the actinia server is explicitly provided. In case the location option is not provided, the active location will be used. The following command lists mapsets of the provided location latlong_wgs84 : ace location=\"latlong_wgs84\" -m ['PERMANENT', 'Sentinel2A', 'globcover', 'modis_ndvi_global'] but only if the actinia user is enabled; otherwise the following message appears: ace location=\"latlong_wgs84\" -m {'message': \"{'Status': 'error', 'Messages': 'Unauthorized access to location \" \"<latlong_wgs84>'}\"} To list all raster maps available in the specified mapset belonging to the provided location nc_spm_08 , run: ace location=\"nc_spm_08\" mapset=\"PERMANENT\" -r ['aspect', 'basin_50K', 'boundary_county_500m', 'cfactorbare_1m', 'cfactorgrow_1m', ... 'urban', 'zipcodes', 'zipcodes_dbl'] Command line examples Running the module g.region in a new ephemeral location, to show the default region of a temporary mapset: ace location=\"nc_spm_08\" grass_command=\"g.region -p\" Resource status accepted Polling: https://actinia.mundialis.de/api/v3/resources/demouser/resource_id-b398b4dd-a47c-4443-a07d-7814cc737973 Resource poll status: finished Processing successfully finished Resource status finished -------------------------------------------------------------------------- projection: 99 (Lambert Conformal Conic) zone: 0 datum: nad83 ellipsoid: a=6378137 es=0.006694380022900787 north: 320000 south: 10000 west: 120000 east: 935000 nsres: 500 ewres: 500 rows: 620 cols: 1630 cells: 1010600 {'resources': [], 'status': 'https://actinia.mundialis.de/api/v3/resources/demouser/resource_id-b398b4dd-a47c-4443-a07d-7814cc737973'} Script examples Example: Orthophoto image segmentation with export Store the following script as text file /tmp/ace_segmentation.sh : # grass ~/grassdata/nc_spm_08/user1/ # Import the web resource and set the region to the imported map # we apply a trick for the import of multi-band GeoTIFFs: # install with: g.extension importer url=https://github.com/mundialis/importer/ importer raster=ortho2010@https://apps.mundialis.de/workshops/osgeo_ireland2017/north_carolina/ortho2010_t792_subset_20cm.tif # The importer has created three new raster maps, one for each band in the geotiff file # stored them in an image group r.info map=ortho2010.1 r.info map=ortho2010.2 r.info map=ortho2010.3 # Set the region and resolution g.region raster=ortho2010.1 res=1 -p # Note: the RGB bands are organized as a group i.segment group=ortho2010 threshold=0.25 output=ortho2010_segment_25+GTiff goodness=ortho2010_seg_25_fit+GTiff # Finally vectorize segments with r.to.vect and export as a GeoJSON file r.to.vect input=ortho2010_segment_25 type=area output=ortho2010_segment_25+GeoJSON Run the script saved in a text file as ace location=\"nc_spm_08\" script=\"/tmp/ace_segmentation.sh\" The results are provided as REST resources for download or consumtion in other systems. Fig. 9: actinia output maps. From left to right: \"ortho2010_segment_25.tif\", \"ortho2010_seg_25_fit.tif\", \"ortho2010_segment_25.geojson\" If you want to try out more things with ace, take a look at a different actinia workshop where a more in-depth look is taken on this topic. actinia Connector - a QGIS plugin Introduction to the actinia Connector The actinia Connector is a QGIS Plugin for actinia communication. With this plugin it is possible to connect to a running actinia instance, request locations, mapsets and detailed layer information. It is also possible to download maps directly into QGIS for further local processing and even to start processes. For ephemeral processing the plugin downloads the results directly. This is still a development version but can be tested and used already. The actinia connector is available from https://apps.mundialis.de/actinia_connector/plugins.xml , simply add this URL in QGIS under Plugins > Manage and install plugins > Settings > Plugin repositories > Add. Project Setup In the actinia Connector plugin you can create a new project or load an old one. When a new project is created, a new project file is created. The user can set a project name and a data directory, where data created by the plugin are saved. Additional the actinia settings have to be set. These settings are the base url, user and password. As simple example you can select the https://actinia.mundialis.de/ with the demouser and password gu3st!pa55w0rd. But you can also use another actinia server or one you have set up yourself. Fig. 10: actinia connector, project setup Location management In the location management screen you can query all locations available for you with the \u201cGet locations\u201d button and then select a location and query its information with the \u201cGet selected location info (region and projection)\u201d button or use this location in another tab for another functionality. Fig. 11: actinia connector, location management Mapset management For mapset management a selected location (in the location tab) is required. From this location all mapsets available for the user can be queried with the \u201cGet mapsets\u201d button. When selecting one of these mapsets, information can be queried with the \u201cGet selected mapset info (region and projection)\u201d button or the layer in this mapset can be used in the raster maps or vector maps tab. Fig. 12: actinia connector, mapset management Raster management For raster management, both a location and a mapset must be selected (these are displayed again at the top). With the \u201cGet raster maps\u201d button all raster layers can be listed. If you select one of them, you can query the map information for it using the \u201cGet selected raster map info\u201d or import the raster map into QGIS. There are two ways to import a raster layer into QGIS. One is to simply use the button \u201cImport selected raster map into QGIS\u201d to import the entire raster map. There is also another possibility to select a layer in QGIS and then additionally select the radio button \u201cby selected layer extent\u201d to limit the extent of the raster map to be imported to the extent of the selected raster map. This extent can also be increased by a number of cells. However, care must be taken that the two maps overlap, otherwise an empty map will be imported into QGIS. Fig. 13: actinia connector, raster management Vector management For vector management, both a location and a mapset must be selected (these are displayed again at the top). With the \u201cGet vector maps\u201d button all vector layers can be listed. If you select one of them, you can query the map information for it using the \u201cGet selected vector map info\u201d or import the vector map into QGIS with the \u201cImport selected vector map into QGIS\u201d button. Fig. 14: actinia connector, vector management Persistent and Ephemeral processing For processing, a location must be selected (in the location tab). Via \u201cLoad process chain\u201d a process chain can be uploaded as a file. This is then displayed on the right. Before the processing can be started, the process type must also be selected. The process can be started as ephermeral or persistent process. If persistent processing is used, a mapset name must be entered in the empty text field. This can be a simple text e.g. \u201cmapset_XY\u201d. The mapset with this name is then created during the processing, and can be loaded afterwards via the tab mapsets. Fig. 15: actinia connector, persistent and ephemeral processing actinia jupyter notebooks Jupyter Notebooks are server-client applications that allow code written in a notebook document to be edited and executed through a web browser. They can be run on a local computer that does not require internet access, as well as used to control computations on a remote server accessed via the Internet. Jupyter notebooks can be interactive and are run through a web browser. They provide the ability to combine live code, explanatory text, and computational results into a single document. Jupyter Notebooks can be easily shared as documents. You can find various actinia notebooks on GitHub . Hint: On error ImportError: cannot import name 'contextfilter' from 'jinja2' (/home/ctawalika/.local/lib/python3.8/site-packages/jinja2/__init__.py) : Remove pip packages with eg pip3 uninstall jinja2 notebook and install them via package manager, e.g. with apt install python3-jinja2 python3-notebook","title":"Client implementations"},{"location":"4_clients/#client-implementations","text":"","title":"Client implementations"},{"location":"4_clients/#actinia-python-client","text":"Python library to access an actinia server easily via python. See also source code and full documentation","title":"actinia-python-client"},{"location":"4_clients/#installation","text":"VERSION=\"0.1.2\" pip3 install \"actinia-python-client @ https://github.com/mundialis/actinia-python-client/releases/download/${VERSION}/actinia_python_client-${VERSION}-py3-none-any.whl\"","title":"Installation"},{"location":"4_clients/#quickstart","text":"Connecting actinia Python library with actinia from actinia import Actinia actinia_mundialis = Actinia() actinia_mundialis.get_version() or connect to actinia-dev with version 3: from actinia import Actinia actinia_dev_mundialis = Actinia(\"https://actinia-dev.mundialis.de/\", \"v3\") actinia_dev_mundialis.get_version() Set authentication to get access to the actinia functionallity actinia_mundialis.set_authentication(\"demouser\", \"gu3st!pa55w0rd\")","title":"Quickstart"},{"location":"4_clients/#location-management","text":"With the location management the locations can be requested as well as information of each location. Also a location can be created and deleted if the user is permitted.","title":"Location Management"},{"location":"4_clients/#get-locations-and-locaton-information-of-a-special-location","text":"locations = actinia_mundialis.get_locations() print(locations.keys()) locations[\"nc_spm_08\"].get_info() # or actinia_mundialis.locations[\"nc_spm_08\"].get_info()","title":"Get locations and locaton information of a special location:"},{"location":"4_clients/#create-a-new-location","text":"(Attention: The demouser is not permitted to create or delete a location!) new_location = actinia_mundialis.create_location(\"test_location\", 25832) print(new_location.name) print(new_location.region) print([loc for loc in actinia_mundialis.locations])","title":"Create a new location"},{"location":"4_clients/#delete-a-location","text":"(Attention: The demouser is not permitted to create or delete a location!) actinia_mundialis.locations[\"test_location\"].delete() print([loc for loc in actinia_mundialis.locations()])","title":"Delete a location"},{"location":"4_clients/#mapset-management","text":"With the mapset management the mapsets of a specified location can be requested as well as information of each mapset. Upcoming: Create and delete mapsets if the user is permitted.","title":"Mapset Management"},{"location":"4_clients/#get-mapsets-of-specified-location","text":"Get mapsets of the nc_spm_08 location: mapsets = actinia_mundialis.locations[\"nc_spm_08\"].get_mapsets() print(mapsets.keys())","title":"Get Mapsets of Specified Location"},{"location":"4_clients/#raster-vector-and-strds-management","text":"","title":"Raster, Vector and STRDS Management"},{"location":"4_clients/#raster-manangement","text":"Get all rasters of the PERMANENT mapsets rasters = mapsets[\"PERMANENT\"].get_raster_layers() print(rasters.keys()) Get information of the raster zipcodes info = rasters[\"zipcodes\"].get_info() Upload a GTif as raster layer to a user mapset (here the user mapset will be created before) # TODO add mapset creation mapset_name = \"test_mapset\" # upload tif raster_layer_name = \"test\" file = \"/home/testuser/data/elevation.tif\" locations[\"nc_spm_08\"].mapsets[mapset_name].upload_raster(raster_layer_name, file) print(locations[\"nc_spm_08\"].mapsets[mapset_name].raster_layers.keys()) Delete a raster layer locations[\"nc_spm_08\"].mapsets[mapset_name].delete_raster(raster_layer_name) print(locations[\"nc_spm_08\"].mapsets[mapset_name].raster_layers.keys()) # TODO delete mapset","title":"Raster manangement"},{"location":"4_clients/#vector-manangement","text":"Get all vector maps of the PERMANENT mapsets vectors = mapsets[\"PERMANENT\"].get_vector_layers() print(vectors.keys()) Get information of the vector boundary_county info = vectors[\"boundary_county\"].get_info() Upload a GeoJSON as vector layer to a user mapset (here the user mapset will be created before) # TODO add mapset creation mapset_name = \"test_mapset\" # upload tif vector_layer_name = \"test\" file = \"/home/testuser/data/firestations.geojson\" locations[\"nc_spm_08\"].mapsets[mapset_name].upload_vector(vector_layer_name, file) print(locations[\"nc_spm_08\"].mapsets[mapset_name].vector_layers.keys()) Delete a raster layer locations[\"nc_spm_08\"].mapsets[mapset_name].delete_vector(vector_layer_name) print(locations[\"nc_spm_08\"].mapsets[mapset_name].vector_layers.keys()) # TODO delete mapset","title":"Vector manangement"},{"location":"4_clients/#process-chain-validation","text":"A process chain can be validated before a job is started. First connecting actinia Python library with actinia and set authentication: from actinia import Actinia actinia_mundialis = Actinia() actinia_mundialis.get_version() actinia_mundialis.set_authentication(\"demouser\", \"gu3st!pa55w0rd\") # request all locations locations = actinia_mundialis.get_locations()","title":"Process Chain Validation"},{"location":"4_clients/#synchronous-process-chain-validation","text":"pc = { \"list\": [ { \"id\": \"r_mapcalc\", \"module\": \"r.mapcalc\", \"inputs\": [ { \"param\": \"expression\", \"value\": \"elevation=42\" } ] } ], \"version\": \"1\" } pc = {\"list\": [{\"id\": \"r_mapcalc\",\"module\": \"r.mapcalc\",\"inputs\": [{\"param\": \"expression\",\"value\": \"elevation=42\"}]}],\"version\": \"1\"} actinia_mundialis.locations[\"nc_spm_08\"].validate_process_chain_sync(pc)","title":"Synchronous process chain validation"},{"location":"4_clients/#asynchronous-process-chain-validation","text":"pc = { \"list\": [ { \"id\": \"r_mapcalc\", \"module\": \"r.mapcalc\", \"inputs\": [ { \"param\": \"expression\", \"value\": \"elevation=42\" } ] } ], \"version\": \"1\" } pc = {\"list\": [{\"id\": \"r_mapcalc\",\"module\": \"r.mapcalc\",\"inputs\": [{\"param\": \"expression\",\"value\": \"elevation=42\"}]}],\"version\": \"1\"} val_job = actinia_mundialis.locations[\"nc_spm_08\"].validate_process_chain_async(pc) val_job.poll_until_finished() print(val_job.status) print(val_job.message)","title":"Asynchronous process chain validation:"},{"location":"4_clients/#processing","text":"Start a processing job with a valid process chain. First connect actinia Python library with actinia and set authentication: from actinia import Actinia actinia_mundialis = Actinia() actinia_mundialis.get_version() actinia_mundialis.set_authentication(\"demouser\", \"gu3st!pa55w0rd\") # request all locations locations = actinia_mundialis.get_locations()","title":"Processing"},{"location":"4_clients/#ephemeral-processing","text":"Start an ephemeral processing job pc = { \"list\": [ { \"id\": \"r_mapcalc\", \"module\": \"r.mapcalc\", \"inputs\": [ { \"param\": \"expression\", \"value\": \"baum=5\" } ] } ], \"version\": \"1\" } job = actinia_mundialis.locations[\"nc_spm_08\"].create_processing_export_job(pc, \"test\") job.poll_until_finished() print(job.status) print(job.message)","title":"Ephemeral Processing"},{"location":"4_clients/#ace-controlling-actinia-from-a-running-grass-gis-session","text":"Python library to access an actinia server easily via python.","title":"ACE - Controlling actinia from a running GRASS GIS session"},{"location":"4_clients/#introduction-to-ace-actinia-command-execution","text":"Controlling actinia from a running GRASS GIS session is a convenient way of writing process chains. It requires some basic GRASS GIS knowledge (for an intro course, e.g. see here ). The ace (actinia command execution) tool allows the execution of a single GRASS GIS command or a list of GRASS GIS commands on an actinia REST service (e.g., https://actinia.mundialis.de/). In addition it provides job management, the ability to list locations, mapsets and map layer the user has access to as well as the creation and deletion of mapsets. The ace tool is a GRASS GIS addon and must be executed in an active GRASS GIS session. All commands will be executed per default in an ephemeral database on the actinia server. Hence, generated output must be exported using augmented GRASS commands to be able to further use it. Note: The option mapset=MAPSET_NAME allows the execution of commands in the persistent user database. It can be used with location=LOCATION_NAME option.","title":"Introduction to ace - actinia command execution"},{"location":"4_clients/#preparation","text":"To use ace, some things are required: GRASS GIS ( download ) three additional Python packages: click requests simplejson pip3 install click requests simplejson nc_spm_08 North Carolina sample location An empty test mapset ace (only for demo) grass -c nc_spm_08/ace ace itself, importer and exporter tools as GRASS GIS extensions g.extension extension=importer url=https://github.com/mundialis/importer g.extension extension=exporter url=https://github.com/mundialis/exporter g.extension extension=ace url=https://github.com/mundialis/ace For more detailed information on how to set this up yourself, see different actinia workshop .","title":"Preparation"},{"location":"4_clients/#authentication-settings","text":"The user must setup the following environmental variables to specify the actinia server and credentials: # set credentials and REST server URL export ACTINIA_USER='demouser' export ACTINIA_PASSWORD='gu3st!pa55w0rd' export ACTINIA_URL='https://actinia.mundialis.de/'","title":"Authentication settings"},{"location":"4_clients/#list-locations-mapsets-and-maps","text":"In order to list the locations the user has access to, run ace -l ['latlong_wgs84', 'nc_spm_08', 'ECAD'] The following command lists mapsets of current location in the active GRASS GIS session (\"nc_spm_08\"): # running ace in the \"nc_spm_08\" location on server: ace location=\"nc_spm_08\" -m ['PERMANENT', 'landsat', 'modis_lst'] All following commands can be executed in any active GRASS GIS location, since the location name at the actinia server is explicitly provided. In case the location option is not provided, the active location will be used. The following command lists mapsets of the provided location latlong_wgs84 : ace location=\"latlong_wgs84\" -m ['PERMANENT', 'Sentinel2A', 'globcover', 'modis_ndvi_global'] but only if the actinia user is enabled; otherwise the following message appears: ace location=\"latlong_wgs84\" -m {'message': \"{'Status': 'error', 'Messages': 'Unauthorized access to location \" \"<latlong_wgs84>'}\"} To list all raster maps available in the specified mapset belonging to the provided location nc_spm_08 , run: ace location=\"nc_spm_08\" mapset=\"PERMANENT\" -r ['aspect', 'basin_50K', 'boundary_county_500m', 'cfactorbare_1m', 'cfactorgrow_1m', ... 'urban', 'zipcodes', 'zipcodes_dbl']","title":"List locations, mapsets and maps"},{"location":"4_clients/#command-line-examples","text":"Running the module g.region in a new ephemeral location, to show the default region of a temporary mapset: ace location=\"nc_spm_08\" grass_command=\"g.region -p\" Resource status accepted Polling: https://actinia.mundialis.de/api/v3/resources/demouser/resource_id-b398b4dd-a47c-4443-a07d-7814cc737973 Resource poll status: finished Processing successfully finished Resource status finished -------------------------------------------------------------------------- projection: 99 (Lambert Conformal Conic) zone: 0 datum: nad83 ellipsoid: a=6378137 es=0.006694380022900787 north: 320000 south: 10000 west: 120000 east: 935000 nsres: 500 ewres: 500 rows: 620 cols: 1630 cells: 1010600 {'resources': [], 'status': 'https://actinia.mundialis.de/api/v3/resources/demouser/resource_id-b398b4dd-a47c-4443-a07d-7814cc737973'}","title":"Command line examples"},{"location":"4_clients/#script-examples","text":"","title":"Script examples"},{"location":"4_clients/#example-orthophoto-image-segmentation-with-export","text":"Store the following script as text file /tmp/ace_segmentation.sh : # grass ~/grassdata/nc_spm_08/user1/ # Import the web resource and set the region to the imported map # we apply a trick for the import of multi-band GeoTIFFs: # install with: g.extension importer url=https://github.com/mundialis/importer/ importer raster=ortho2010@https://apps.mundialis.de/workshops/osgeo_ireland2017/north_carolina/ortho2010_t792_subset_20cm.tif # The importer has created three new raster maps, one for each band in the geotiff file # stored them in an image group r.info map=ortho2010.1 r.info map=ortho2010.2 r.info map=ortho2010.3 # Set the region and resolution g.region raster=ortho2010.1 res=1 -p # Note: the RGB bands are organized as a group i.segment group=ortho2010 threshold=0.25 output=ortho2010_segment_25+GTiff goodness=ortho2010_seg_25_fit+GTiff # Finally vectorize segments with r.to.vect and export as a GeoJSON file r.to.vect input=ortho2010_segment_25 type=area output=ortho2010_segment_25+GeoJSON Run the script saved in a text file as ace location=\"nc_spm_08\" script=\"/tmp/ace_segmentation.sh\" The results are provided as REST resources for download or consumtion in other systems. Fig. 9: actinia output maps. From left to right: \"ortho2010_segment_25.tif\", \"ortho2010_seg_25_fit.tif\", \"ortho2010_segment_25.geojson\" If you want to try out more things with ace, take a look at a different actinia workshop where a more in-depth look is taken on this topic.","title":"Example: Orthophoto image segmentation with export"},{"location":"4_clients/#actinia-connector-a-qgis-plugin","text":"","title":"actinia Connector - a QGIS plugin"},{"location":"4_clients/#introduction-to-the-actinia-connector","text":"The actinia Connector is a QGIS Plugin for actinia communication. With this plugin it is possible to connect to a running actinia instance, request locations, mapsets and detailed layer information. It is also possible to download maps directly into QGIS for further local processing and even to start processes. For ephemeral processing the plugin downloads the results directly. This is still a development version but can be tested and used already. The actinia connector is available from https://apps.mundialis.de/actinia_connector/plugins.xml , simply add this URL in QGIS under Plugins > Manage and install plugins > Settings > Plugin repositories > Add.","title":"Introduction to the actinia Connector"},{"location":"4_clients/#project-setup","text":"In the actinia Connector plugin you can create a new project or load an old one. When a new project is created, a new project file is created. The user can set a project name and a data directory, where data created by the plugin are saved. Additional the actinia settings have to be set. These settings are the base url, user and password. As simple example you can select the https://actinia.mundialis.de/ with the demouser and password gu3st!pa55w0rd. But you can also use another actinia server or one you have set up yourself. Fig. 10: actinia connector, project setup","title":"Project Setup"},{"location":"4_clients/#location-management_1","text":"In the location management screen you can query all locations available for you with the \u201cGet locations\u201d button and then select a location and query its information with the \u201cGet selected location info (region and projection)\u201d button or use this location in another tab for another functionality. Fig. 11: actinia connector, location management","title":"Location management"},{"location":"4_clients/#mapset-management_1","text":"For mapset management a selected location (in the location tab) is required. From this location all mapsets available for the user can be queried with the \u201cGet mapsets\u201d button. When selecting one of these mapsets, information can be queried with the \u201cGet selected mapset info (region and projection)\u201d button or the layer in this mapset can be used in the raster maps or vector maps tab. Fig. 12: actinia connector, mapset management","title":"Mapset management"},{"location":"4_clients/#raster-management","text":"For raster management, both a location and a mapset must be selected (these are displayed again at the top). With the \u201cGet raster maps\u201d button all raster layers can be listed. If you select one of them, you can query the map information for it using the \u201cGet selected raster map info\u201d or import the raster map into QGIS. There are two ways to import a raster layer into QGIS. One is to simply use the button \u201cImport selected raster map into QGIS\u201d to import the entire raster map. There is also another possibility to select a layer in QGIS and then additionally select the radio button \u201cby selected layer extent\u201d to limit the extent of the raster map to be imported to the extent of the selected raster map. This extent can also be increased by a number of cells. However, care must be taken that the two maps overlap, otherwise an empty map will be imported into QGIS. Fig. 13: actinia connector, raster management","title":"Raster management"},{"location":"4_clients/#vector-management","text":"For vector management, both a location and a mapset must be selected (these are displayed again at the top). With the \u201cGet vector maps\u201d button all vector layers can be listed. If you select one of them, you can query the map information for it using the \u201cGet selected vector map info\u201d or import the vector map into QGIS with the \u201cImport selected vector map into QGIS\u201d button. Fig. 14: actinia connector, vector management","title":"Vector management"},{"location":"4_clients/#persistent-and-ephemeral-processing","text":"For processing, a location must be selected (in the location tab). Via \u201cLoad process chain\u201d a process chain can be uploaded as a file. This is then displayed on the right. Before the processing can be started, the process type must also be selected. The process can be started as ephermeral or persistent process. If persistent processing is used, a mapset name must be entered in the empty text field. This can be a simple text e.g. \u201cmapset_XY\u201d. The mapset with this name is then created during the processing, and can be loaded afterwards via the tab mapsets. Fig. 15: actinia connector, persistent and ephemeral processing","title":"Persistent and Ephemeral processing"},{"location":"4_clients/#actinia-jupyter-notebooks","text":"Jupyter Notebooks are server-client applications that allow code written in a notebook document to be edited and executed through a web browser. They can be run on a local computer that does not require internet access, as well as used to control computations on a remote server accessed via the Internet. Jupyter notebooks can be interactive and are run through a web browser. They provide the ability to combine live code, explanatory text, and computational results into a single document. Jupyter Notebooks can be easily shared as documents. You can find various actinia notebooks on GitHub . Hint: On error ImportError: cannot import name 'contextfilter' from 'jinja2' (/home/ctawalika/.local/lib/python3.8/site-packages/jinja2/__init__.py) : Remove pip packages with eg pip3 uninstall jinja2 notebook and install them via package manager, e.g. with apt install python3-jinja2 python3-notebook","title":"actinia jupyter notebooks"},{"location":"5_excercises/","text":"Own exercises in actinia Meanwhile you have seen a lot of material. Time to try out some further exercises... 1. What is the altitude of the highest point in North Carolina? Check it with actinia. Find the correct raster in the North Carolina location and PERMANENT mapset. Find the relevant raster layer by rendering it Print the information and get altitude of the highest point List of available data in the North Carolina sample dataset. 2. Find the zipcode in Wake county with the most hospitals Find the relevant vector layers Check the zipcode vector layer for the relevant column to get the zipcode Create a process chain as a .json file to ask for the number of hospitals in the zipcodes: Use the GRASS GIS modules g.copy (because you are not allowed to change data from an other mapset), v.vect.stats and v.db.select Post the created process chain to https://actinia.mundialis.de/api/v3/locations/nc_spm_08/processing_async for ephemeral processing Related GRASS GIS manual pages: g.copy , v.vect.stats , v.db.select . 3. Export the water bodies from the available Landsat imagery of North Carolina Create a process chain as a .json file Remember to set the computational region Compute the NDWI (Normalized difference water index); use r.mapcalc or i.vi Filter water bodies by a threshold of e.g. 0.35 using r.mapcalc Either export the water bodies (use the exporter with the ephemeral processing) or render the maps of NDWI and water bodies with a nice color (use r.colors and persistent processing in your own mapset) Related GRASS GIS manual pages: r.mapcalc , i.vi , exporter . 4. Population at risk near coastal areas needed geodata: Worldwide SRTM 30m (already available in actinia as srtmgl1_v003_30m - find out the location yourself) South America Population 2015 (already available in actinia as worldpop_2015_1km_aggregated_UNadj - find out the location yourself) raster shorelines (already available in actinia as ne_1000m_coastlines - find out the location yourself) fetch metadata with actinia interface and render input data proposed workflow: set computational region to a small subregion (hint: align the region resolution to the population raster) and check the pixel number against user constraints buffer the coastlines by 5000 m and set a mask to the result Extract only the peopulation below 10 m Calculate the statistic to get the population at risk near coastal areas Hints for example GRASS modules to use in process chain: g.region , r.buffer , r.mapcalc , r.mask , r.univar Related GRASS GIS manual pages: g.region , r.buffer , r.mask , r.univar .","title":"Own exercises in actinia"},{"location":"5_excercises/#own-exercises-in-actinia","text":"Meanwhile you have seen a lot of material. Time to try out some further exercises...","title":"Own exercises in actinia"},{"location":"5_excercises/#1-what-is-the-altitude-of-the-highest-point-in-north-carolina-check-it-with-actinia","text":"Find the correct raster in the North Carolina location and PERMANENT mapset. Find the relevant raster layer by rendering it Print the information and get altitude of the highest point List of available data in the North Carolina sample dataset.","title":"1. What is the altitude of the highest point in North Carolina? Check it with actinia."},{"location":"5_excercises/#2-find-the-zipcode-in-wake-county-with-the-most-hospitals","text":"Find the relevant vector layers Check the zipcode vector layer for the relevant column to get the zipcode Create a process chain as a .json file to ask for the number of hospitals in the zipcodes: Use the GRASS GIS modules g.copy (because you are not allowed to change data from an other mapset), v.vect.stats and v.db.select Post the created process chain to https://actinia.mundialis.de/api/v3/locations/nc_spm_08/processing_async for ephemeral processing Related GRASS GIS manual pages: g.copy , v.vect.stats , v.db.select .","title":"2. Find the zipcode in Wake county with the most hospitals"},{"location":"5_excercises/#3-export-the-water-bodies-from-the-available-landsat-imagery-of-north-carolina","text":"Create a process chain as a .json file Remember to set the computational region Compute the NDWI (Normalized difference water index); use r.mapcalc or i.vi Filter water bodies by a threshold of e.g. 0.35 using r.mapcalc Either export the water bodies (use the exporter with the ephemeral processing) or render the maps of NDWI and water bodies with a nice color (use r.colors and persistent processing in your own mapset) Related GRASS GIS manual pages: r.mapcalc , i.vi , exporter .","title":"3. Export the water bodies from the available Landsat imagery of North Carolina"},{"location":"5_excercises/#4-population-at-risk-near-coastal-areas","text":"needed geodata: Worldwide SRTM 30m (already available in actinia as srtmgl1_v003_30m - find out the location yourself) South America Population 2015 (already available in actinia as worldpop_2015_1km_aggregated_UNadj - find out the location yourself) raster shorelines (already available in actinia as ne_1000m_coastlines - find out the location yourself) fetch metadata with actinia interface and render input data proposed workflow: set computational region to a small subregion (hint: align the region resolution to the population raster) and check the pixel number against user constraints buffer the coastlines by 5000 m and set a mask to the result Extract only the peopulation below 10 m Calculate the statistic to get the population at risk near coastal areas Hints for example GRASS modules to use in process chain: g.region , r.buffer , r.mapcalc , r.mask , r.univar Related GRASS GIS manual pages: g.region , r.buffer , r.mask , r.univar .","title":"4. Population at risk near coastal areas"},{"location":"6_conclusions/","text":"Conclusions and future Discussion! Where is the code and how to contribute: find it on GitHub https://github.com/mundialis/actinia_core/ UPCOMING FOSS4G 2022 talk \"News from actinia - let`s STAC!\" 2022-08-24, 15:15\u201315:45, Room Onice FOSS4G 2022 OSGeo Community sprint details in OSGeo Wiki See also What does actinia mean? Actinia is a beautiful sea creature and a genus of sea anemones in the family Actiniidae (see wikipedia ). While the sea creature is filtering the sea water, the actinia geoprocessing platform filters in large data oceans. How to contribute to actinia Please see CONTRIBUTING.md openEO resources OpenEO Web Editor: https://open-eo.github.io/openeo-web-editor/demo/ Server: https://openeo.mundialis.de user, password: upon request actinia, plugins and related repositories actinia_core actinia-module-plugin actinia-metadata-plugin actinia_satellite_plugin actinia_statistic_plugin actinia-stac-plugin ace exporter importer helm charts openeo-grassgis-drives REST introduction What is REST - A Simple Explanation for Beginners, Part 1: Introduction What is REST - A Simple Explanation for Beginners, Part 2: REST Constraints Using command line on Windows Git for Windows offers the \"git bash\" and common tools MSYS2 offers a bash and many tools along with pacman to install further packages References [1] Zell Liew, 2018: Understanding And Using REST APIs, https://www.smashingmagazine.com/2018/01/understanding-using-rest-api/ [2] Planet 2019: Developer resource center, https://developers.planet.com/planetschool/rest-apis/ [3] actinia API reference documentation [4] actinia article: Acknowledgement The review by Vero Andreo is greatly appreciated. As already mentioned above, this workshop is a fork of an actinia workshop by Markus Neteler. Main content was reused, some adjustments were made. Last but not least thanks to Anika Weinmann for creating the documentation about actinia Connector and - in teamwork together with Guido Riembauer - for updating the excercises and creating new fun and smaller tasks. Repository of this material on github About | Privacy","title":"Conclusions and future"},{"location":"6_conclusions/#conclusions-and-future","text":"Discussion! Where is the code and how to contribute: find it on GitHub https://github.com/mundialis/actinia_core/","title":"Conclusions and future"},{"location":"6_conclusions/#upcoming","text":"","title":"UPCOMING"},{"location":"6_conclusions/#foss4g-2022-talk-news-from-actinia-lets-stac","text":"2022-08-24, 15:15\u201315:45, Room Onice","title":"FOSS4G 2022 talk \"News from actinia - let`s STAC!\""},{"location":"6_conclusions/#foss4g-2022-osgeo-community-sprint","text":"details in OSGeo Wiki","title":"FOSS4G 2022 OSGeo Community sprint"},{"location":"6_conclusions/#see-also","text":"","title":"See also"},{"location":"6_conclusions/#what-does-actinia-mean","text":"Actinia is a beautiful sea creature and a genus of sea anemones in the family Actiniidae (see wikipedia ). While the sea creature is filtering the sea water, the actinia geoprocessing platform filters in large data oceans.","title":"What does actinia mean?"},{"location":"6_conclusions/#how-to-contribute-to-actinia","text":"Please see CONTRIBUTING.md","title":"How to contribute to actinia"},{"location":"6_conclusions/#openeo-resources","text":"OpenEO Web Editor: https://open-eo.github.io/openeo-web-editor/demo/ Server: https://openeo.mundialis.de user, password: upon request","title":"openEO resources"},{"location":"6_conclusions/#actinia-plugins-and-related-repositories","text":"actinia_core actinia-module-plugin actinia-metadata-plugin actinia_satellite_plugin actinia_statistic_plugin actinia-stac-plugin ace exporter importer helm charts openeo-grassgis-drives","title":"actinia, plugins and related repositories"},{"location":"6_conclusions/#rest-introduction","text":"What is REST - A Simple Explanation for Beginners, Part 1: Introduction What is REST - A Simple Explanation for Beginners, Part 2: REST Constraints","title":"REST introduction"},{"location":"6_conclusions/#using-command-line-on-windows","text":"Git for Windows offers the \"git bash\" and common tools MSYS2 offers a bash and many tools along with pacman to install further packages","title":"Using command line on Windows"},{"location":"6_conclusions/#references","text":"[1] Zell Liew, 2018: Understanding And Using REST APIs, https://www.smashingmagazine.com/2018/01/understanding-using-rest-api/ [2] Planet 2019: Developer resource center, https://developers.planet.com/planetschool/rest-apis/ [3] actinia API reference documentation [4] actinia article:","title":"References"},{"location":"6_conclusions/#acknowledgement","text":"The review by Vero Andreo is greatly appreciated. As already mentioned above, this workshop is a fork of an actinia workshop by Markus Neteler. Main content was reused, some adjustments were made. Last but not least thanks to Anika Weinmann for creating the documentation about actinia Connector and - in teamwork together with Guido Riembauer - for updating the excercises and creating new fun and smaller tasks. Repository of this material on github About | Privacy","title":"Acknowledgement"},{"location":"about/","text":"About the trainers Markus Neteler is co-founder of mundialis GmbH & Co. KG, Bonn, Germany. From 2001-2015 he worked as a researcher in Italy. Markus is co-founder of OSGeo and since 1998, coordinator of the GRASS GIS development (for details, see his private homepage ). Carmen Tawalika started working for mundialis in 2015 as the first developer. Growing together with the company, her passion for open source software never faded. In 2016 she was in the FOSS4G Bonn organization team and responsible for the workshops. In 2019 she became a member of OSGeo. She is heavily involved in the development of actinia and a member of the PSC. Anika Weinmann studied geodesy and geoinformation at the University of Bonn. In her master thesis she specializes in solving remote sensing tasks with a Deep Learning approach. She started working for mundialis in 2018, contributes to actinia and is a member of the PSC. Guido Riembauer studied Geoinformation and Visualisation at University of Potsdam and worked as a trainee for ESA\u2019s Earth Observation Programme before joining mundialis in early 2020. He is a developer and data analyst at mundialis and has specialized in (radar) remote sensing. Guido is involved in the development of GRASS-GIS and actinia modules to import and analyse Copernicus Sentinel data. Any feedback? Please write to me at: neteler @ mundialis.de Privacy","title":"About the trainers"},{"location":"about/#about-the-trainers","text":"Markus Neteler is co-founder of mundialis GmbH & Co. KG, Bonn, Germany. From 2001-2015 he worked as a researcher in Italy. Markus is co-founder of OSGeo and since 1998, coordinator of the GRASS GIS development (for details, see his private homepage ). Carmen Tawalika started working for mundialis in 2015 as the first developer. Growing together with the company, her passion for open source software never faded. In 2016 she was in the FOSS4G Bonn organization team and responsible for the workshops. In 2019 she became a member of OSGeo. She is heavily involved in the development of actinia and a member of the PSC. Anika Weinmann studied geodesy and geoinformation at the University of Bonn. In her master thesis she specializes in solving remote sensing tasks with a Deep Learning approach. She started working for mundialis in 2018, contributes to actinia and is a member of the PSC. Guido Riembauer studied Geoinformation and Visualisation at University of Potsdam and worked as a trainee for ESA\u2019s Earth Observation Programme before joining mundialis in early 2020. He is a developer and data analyst at mundialis and has specialized in (radar) remote sensing. Guido is involved in the development of GRASS-GIS and actinia modules to import and analyse Copernicus Sentinel data.","title":"About the trainers"},{"location":"about/#any-feedback","text":"Please write to me at: neteler @ mundialis.de Privacy","title":"Any feedback?"},{"location":"solution/exercises_solution/","text":"Own exercises in actinia - solution SMALL EXERCISES 1. altitude of the highest point in North Carolina statisitcs of elevation map: https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/PERMANENT/raster_layers/elev_state_500m curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/PERMANENT/raster_layers/elev_state_500m | jq answer: 1952.0009637576 m (max) zum Vergleich https://de.wikipedia.org/wiki/Mount_Mitchell 2037m 2. zipcode in Wake county with the most hospitals vector layer: zipcodes: https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/PERMANENT/vector_layers/zipcodes_wake/render hospitals: https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/PERMANENT/vector_layers/hospitals/render PC: exercise02_hospitals.json ephemeral processing ``` curl -u \"foss4g2022:shuDo6oo\" -X POST https://actinia.mundialis.de/api/v3/locations/nc_spm_08/processing_async -H 'accept: application/json' -H 'Content-Type: application/json' -d @exercise02_hospitals.json | jq curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/resources/foss4g2022/resource_id-... | jq ``` * answer: 2 hospitals in \"RALEIGH 27603\" 3. water bodies from the available Landsat imagery PC: exercise03_ndwi.json ephemeral processing with export ``` curl -u \"foss4g2022:shuDo6oo\" -X POST https://actinia.mundialis.de/api/v3/locations/nc_spm_08/processing_async_export -H 'accept: application/json' -H 'Content-Type: application/json' -d @exercise03_ndwi.json | jq curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/resources/foss4g2022/... | jq * persistent processing with color setting curl -u \"foss4g2022:shuDo6oo\" -X POST https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/workshop_gr_aw/processing_async -H 'accept: application/json' -H 'Content-Type: application/json' -d @exercise03_ndwi.json | jq curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/resources/foss4g2022/... | jq ``` * https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/workshop_gr_aw/raster_layers/ndwi_1/render * https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/workshop_gr_aw/raster_layers/water_bodies/render EXERCISE: \"Population at risk near coastal areas\" Data: SRTM: https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/srtmgl1_30m/raster_layers/srtmgl1_v003_30m/render Population: https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/worldpop_south_america/raster_layers/worldpop_2015_1km_aggregated_UNadj/render coastline: https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/coastlines/raster_layers/ne_1000m_coastline/render # SRTM 30m curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/srtmgl1_30m/raster_layers/srtmgl1_v003_30m # Population curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/worldpop_south_america/raster_layers/worldpop_2015_1km_aggregated_UNadj | jq # coastline raster curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/coastlines/raster_layers/ne_1000m_coastline | jq PC: exercise_pop.json persistent processing: ``` curl -u \"foss4g2022:shuDo6oo\" -X POST https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/workshop_gr_aw/processing -H 'accept: application/json' -H 'Content-Type: application/json' -d @exercise_pop.json | jq curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/resources/foss4g2022/resource_id-... | jq ``` * answer: 759932 people (sum) * https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/workshop_gr_aw/raster_layers/peop/render","title":"Own exercises in actinia - solution"},{"location":"solution/exercises_solution/#own-exercises-in-actinia-solution","text":"","title":"Own exercises in actinia - solution"},{"location":"solution/exercises_solution/#small-exercises","text":"","title":"SMALL EXERCISES"},{"location":"solution/exercises_solution/#1-altitude-of-the-highest-point-in-north-carolina","text":"statisitcs of elevation map: https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/PERMANENT/raster_layers/elev_state_500m curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/PERMANENT/raster_layers/elev_state_500m | jq answer: 1952.0009637576 m (max) zum Vergleich https://de.wikipedia.org/wiki/Mount_Mitchell 2037m","title":"1. altitude of the highest point in North Carolina"},{"location":"solution/exercises_solution/#2-zipcode-in-wake-county-with-the-most-hospitals","text":"vector layer: zipcodes: https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/PERMANENT/vector_layers/zipcodes_wake/render hospitals: https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/PERMANENT/vector_layers/hospitals/render PC: exercise02_hospitals.json ephemeral processing ``` curl -u \"foss4g2022:shuDo6oo\" -X POST https://actinia.mundialis.de/api/v3/locations/nc_spm_08/processing_async -H 'accept: application/json' -H 'Content-Type: application/json' -d @exercise02_hospitals.json | jq curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/resources/foss4g2022/resource_id-... | jq ``` * answer: 2 hospitals in \"RALEIGH 27603\"","title":"2. zipcode in Wake county with the most hospitals"},{"location":"solution/exercises_solution/#3-water-bodies-from-the-available-landsat-imagery","text":"PC: exercise03_ndwi.json ephemeral processing with export ``` curl -u \"foss4g2022:shuDo6oo\" -X POST https://actinia.mundialis.de/api/v3/locations/nc_spm_08/processing_async_export -H 'accept: application/json' -H 'Content-Type: application/json' -d @exercise03_ndwi.json | jq curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/resources/foss4g2022/... | jq * persistent processing with color setting curl -u \"foss4g2022:shuDo6oo\" -X POST https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/workshop_gr_aw/processing_async -H 'accept: application/json' -H 'Content-Type: application/json' -d @exercise03_ndwi.json | jq curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/resources/foss4g2022/... | jq ``` * https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/workshop_gr_aw/raster_layers/ndwi_1/render * https://actinia.mundialis.de/api/v3/locations/nc_spm_08/mapsets/workshop_gr_aw/raster_layers/water_bodies/render","title":"3. water bodies from the available Landsat imagery"},{"location":"solution/exercises_solution/#exercise-population-at-risk-near-coastal-areas","text":"Data: SRTM: https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/srtmgl1_30m/raster_layers/srtmgl1_v003_30m/render Population: https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/worldpop_south_america/raster_layers/worldpop_2015_1km_aggregated_UNadj/render coastline: https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/coastlines/raster_layers/ne_1000m_coastline/render # SRTM 30m curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/srtmgl1_30m/raster_layers/srtmgl1_v003_30m # Population curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/worldpop_south_america/raster_layers/worldpop_2015_1km_aggregated_UNadj | jq # coastline raster curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/coastlines/raster_layers/ne_1000m_coastline | jq PC: exercise_pop.json persistent processing: ``` curl -u \"foss4g2022:shuDo6oo\" -X POST https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/workshop_gr_aw/processing -H 'accept: application/json' -H 'Content-Type: application/json' -d @exercise_pop.json | jq curl -u \"foss4g2022:shuDo6oo\" -X GET https://actinia.mundialis.de/api/v3/resources/foss4g2022/resource_id-... | jq ``` * answer: 759932 people (sum) * https://actinia.mundialis.de/api/v3/locations/latlong_wgs84/mapsets/workshop_gr_aw/raster_layers/peop/render","title":"EXERCISE: \"Population at risk near coastal areas\""}]}